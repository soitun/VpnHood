//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

namespace VpnHood.AccessServer.Api {

export class AccessesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(projectId: string, accessId: string): Promise<AccessData> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/accesses/{accessId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (accessId === undefined || accessId === null)
            throw new Error("The parameter 'accessId' must be defined.");
        url_ = url_.replace("{accessId}", encodeURIComponent("" + accessId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<AccessData> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccessData.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AccessData>(null as any);
    }

    list(projectId: string, accessTokenId: string | null | undefined, serverFarmId: string | null | undefined, accessId: string | null | undefined, beginTime: Date | null | undefined, endTime: Date | null | undefined, recordIndex: number | undefined, recordCount: number | undefined): Promise<ListResultOfAccessData> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/accesses?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (accessTokenId !== undefined && accessTokenId !== null)
            url_ += "accessTokenId=" + encodeURIComponent("" + accessTokenId) + "&";
        if (serverFarmId !== undefined && serverFarmId !== null)
            url_ += "serverFarmId=" + encodeURIComponent("" + serverFarmId) + "&";
        if (accessId !== undefined && accessId !== null)
            url_ += "accessId=" + encodeURIComponent("" + accessId) + "&";
        if (beginTime !== undefined && beginTime !== null)
            url_ += "beginTime=" + encodeURIComponent(beginTime ? "" + beginTime.toISOString() : "") + "&";
        if (endTime !== undefined && endTime !== null)
            url_ += "endTime=" + encodeURIComponent(endTime ? "" + endTime.toISOString() : "") + "&";
        if (recordIndex === null)
            throw new Error("The parameter 'recordIndex' cannot be null.");
        else if (recordIndex !== undefined)
            url_ += "recordIndex=" + encodeURIComponent("" + recordIndex) + "&";
        if (recordCount === null)
            throw new Error("The parameter 'recordCount' cannot be null.");
        else if (recordCount !== undefined)
            url_ += "recordCount=" + encodeURIComponent("" + recordCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList(_response);
        });
    }

    protected processList(response: Response): Promise<ListResultOfAccessData> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultOfAccessData.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListResultOfAccessData>(null as any);
    }
}

export class AccessTokensClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    create(projectId: string, createParams: AccessTokenCreateParams): Promise<AccessToken> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/access-tokens";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createParams);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<AccessToken> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccessToken.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AccessToken>(null as any);
    }

    list(projectId: string, search: string | null | undefined, accessTokenId: string | null | undefined, serverFarmId: string | null | undefined, usageBeginTime: Date | null | undefined, usageEndTime: Date | null | undefined, recordIndex: number | undefined, recordCount: number | undefined): Promise<ListResultOfAccessTokenData> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/access-tokens?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (accessTokenId !== undefined && accessTokenId !== null)
            url_ += "accessTokenId=" + encodeURIComponent("" + accessTokenId) + "&";
        if (serverFarmId !== undefined && serverFarmId !== null)
            url_ += "serverFarmId=" + encodeURIComponent("" + serverFarmId) + "&";
        if (usageBeginTime !== undefined && usageBeginTime !== null)
            url_ += "usageBeginTime=" + encodeURIComponent(usageBeginTime ? "" + usageBeginTime.toISOString() : "") + "&";
        if (usageEndTime !== undefined && usageEndTime !== null)
            url_ += "usageEndTime=" + encodeURIComponent(usageEndTime ? "" + usageEndTime.toISOString() : "") + "&";
        if (recordIndex === null)
            throw new Error("The parameter 'recordIndex' cannot be null.");
        else if (recordIndex !== undefined)
            url_ += "recordIndex=" + encodeURIComponent("" + recordIndex) + "&";
        if (recordCount === null)
            throw new Error("The parameter 'recordCount' cannot be null.");
        else if (recordCount !== undefined)
            url_ += "recordCount=" + encodeURIComponent("" + recordCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList(_response);
        });
    }

    protected processList(response: Response): Promise<ListResultOfAccessTokenData> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultOfAccessTokenData.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListResultOfAccessTokenData>(null as any);
    }

    deleteMany(projectId: string, accessTokenIds: string[]): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/access-tokens";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(accessTokenIds);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteMany(_response);
        });
    }

    protected processDeleteMany(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    update(projectId: string, accessTokenId: string, updateParams: AccessTokenUpdateParams): Promise<AccessToken> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/access-tokens/{accessTokenId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (accessTokenId === undefined || accessTokenId === null)
            throw new Error("The parameter 'accessTokenId' must be defined.");
        url_ = url_.replace("{accessTokenId}", encodeURIComponent("" + accessTokenId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateParams);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<AccessToken> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccessToken.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AccessToken>(null as any);
    }

    get(projectId: string, accessTokenId: string, usageBeginTime: Date | null | undefined, usageEndTime: Date | null | undefined): Promise<AccessTokenData> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/access-tokens/{accessTokenId}?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (accessTokenId === undefined || accessTokenId === null)
            throw new Error("The parameter 'accessTokenId' must be defined.");
        url_ = url_.replace("{accessTokenId}", encodeURIComponent("" + accessTokenId));
        if (usageBeginTime !== undefined && usageBeginTime !== null)
            url_ += "usageBeginTime=" + encodeURIComponent(usageBeginTime ? "" + usageBeginTime.toISOString() : "") + "&";
        if (usageEndTime !== undefined && usageEndTime !== null)
            url_ += "usageEndTime=" + encodeURIComponent(usageEndTime ? "" + usageEndTime.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<AccessTokenData> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccessTokenData.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AccessTokenData>(null as any);
    }

    delete(projectId: string, accessTokenId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/access-tokens/{accessTokenId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (accessTokenId === undefined || accessTokenId === null)
            throw new Error("The parameter 'accessTokenId' must be defined.");
        url_ = url_.replace("{accessTokenId}", encodeURIComponent("" + accessTokenId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getAccessKey(projectId: string, accessTokenId: string): Promise<string> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/access-tokens/{accessTokenId}/access-key";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (accessTokenId === undefined || accessTokenId === null)
            throw new Error("The parameter 'accessTokenId' must be defined.");
        url_ = url_.replace("{accessTokenId}", encodeURIComponent("" + accessTokenId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAccessKey(_response);
        });
    }

    protected processGetAccessKey(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }
}

export class CertificatesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    createBySelfSigned(projectId: string, createParams: CertificateSelfSignedParams): Promise<Certificate> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/certificates/self-signed";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createParams);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateBySelfSigned(_response);
        });
    }

    protected processCreateBySelfSigned(response: Response): Promise<Certificate> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Certificate.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Certificate>(null as any);
    }

    replaceBySelfSigned(projectId: string, certificateId: string, createParams: CertificateSelfSignedParams | undefined): Promise<Certificate> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/certificates/{certificateId}/self-signed";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (certificateId === undefined || certificateId === null)
            throw new Error("The parameter 'certificateId' must be defined.");
        url_ = url_.replace("{certificateId}", encodeURIComponent("" + certificateId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createParams);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReplaceBySelfSigned(_response);
        });
    }

    protected processReplaceBySelfSigned(response: Response): Promise<Certificate> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Certificate.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Certificate>(null as any);
    }

    createByImport(projectId: string, importParams: CertificateImportParams): Promise<Certificate> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/certificates/import";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(importParams);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateByImport(_response);
        });
    }

    protected processCreateByImport(response: Response): Promise<Certificate> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Certificate.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Certificate>(null as any);
    }

    replaceByImport(projectId: string, certificateId: string, importParams: CertificateImportParams): Promise<Certificate> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/certificates/{certificateId}/import";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (certificateId === undefined || certificateId === null)
            throw new Error("The parameter 'certificateId' must be defined.");
        url_ = url_.replace("{certificateId}", encodeURIComponent("" + certificateId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(importParams);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReplaceByImport(_response);
        });
    }

    protected processReplaceByImport(response: Response): Promise<Certificate> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Certificate.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Certificate>(null as any);
    }

    get(projectId: string, certificateId: string, includeSummary: boolean | undefined): Promise<CertificateData> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/certificates/{certificateId}?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (certificateId === undefined || certificateId === null)
            throw new Error("The parameter 'certificateId' must be defined.");
        url_ = url_.replace("{certificateId}", encodeURIComponent("" + certificateId));
        if (includeSummary === null)
            throw new Error("The parameter 'includeSummary' cannot be null.");
        else if (includeSummary !== undefined)
            url_ += "includeSummary=" + encodeURIComponent("" + includeSummary) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<CertificateData> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CertificateData.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CertificateData>(null as any);
    }

    delete(projectId: string, certificateId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/certificates/{certificateId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (certificateId === undefined || certificateId === null)
            throw new Error("The parameter 'certificateId' must be defined.");
        url_ = url_.replace("{certificateId}", encodeURIComponent("" + certificateId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    list(projectId: string, search: string | null | undefined, includeSummary: boolean | undefined, recordIndex: number | undefined, recordCount: number | undefined): Promise<CertificateData[]> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/certificates?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (includeSummary === null)
            throw new Error("The parameter 'includeSummary' cannot be null.");
        else if (includeSummary !== undefined)
            url_ += "includeSummary=" + encodeURIComponent("" + includeSummary) + "&";
        if (recordIndex === null)
            throw new Error("The parameter 'recordIndex' cannot be null.");
        else if (recordIndex !== undefined)
            url_ += "recordIndex=" + encodeURIComponent("" + recordIndex) + "&";
        if (recordCount === null)
            throw new Error("The parameter 'recordCount' cannot be null.");
        else if (recordCount !== undefined)
            url_ += "recordCount=" + encodeURIComponent("" + recordCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList(_response);
        });
    }

    protected processList(response: Response): Promise<CertificateData[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CertificateData.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CertificateData[]>(null as any);
    }
}

export class DevicesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(projectId: string, deviceId: string, usageBeginTime: Date | null | undefined, usageEndTime: Date | null | undefined): Promise<DeviceData> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/devices/{deviceId}?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        if (usageBeginTime !== undefined && usageBeginTime !== null)
            url_ += "usageBeginTime=" + encodeURIComponent(usageBeginTime ? "" + usageBeginTime.toISOString() : "") + "&";
        if (usageEndTime !== undefined && usageEndTime !== null)
            url_ += "usageEndTime=" + encodeURIComponent(usageEndTime ? "" + usageEndTime.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<DeviceData> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceData.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceData>(null as any);
    }

    update(projectId: string, deviceId: string, updateParams: DeviceUpdateParams): Promise<Device> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/devices/{deviceId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateParams);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<Device> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Device.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Device>(null as any);
    }

    findByClientId(projectId: string, clientId: string): Promise<Device> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/devices/clientId:{clientId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindByClientId(_response);
        });
    }

    protected processFindByClientId(response: Response): Promise<Device> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Device.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Device>(null as any);
    }

    list(projectId: string, deviceId: string | null | undefined, usageBeginTime: Date | null | undefined, usageEndTime: Date | null | undefined, recordIndex: number | undefined, recordCount: number | undefined): Promise<DeviceData[]> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/devices?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (deviceId !== undefined && deviceId !== null)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (usageBeginTime !== undefined && usageBeginTime !== null)
            url_ += "usageBeginTime=" + encodeURIComponent(usageBeginTime ? "" + usageBeginTime.toISOString() : "") + "&";
        if (usageEndTime !== undefined && usageEndTime !== null)
            url_ += "usageEndTime=" + encodeURIComponent(usageEndTime ? "" + usageEndTime.toISOString() : "") + "&";
        if (recordIndex === null)
            throw new Error("The parameter 'recordIndex' cannot be null.");
        else if (recordIndex !== undefined)
            url_ += "recordIndex=" + encodeURIComponent("" + recordIndex) + "&";
        if (recordCount === null)
            throw new Error("The parameter 'recordCount' cannot be null.");
        else if (recordCount !== undefined)
            url_ += "recordCount=" + encodeURIComponent("" + recordCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList(_response);
        });
    }

    protected processList(response: Response): Promise<DeviceData[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DeviceData.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceData[]>(null as any);
    }

    listUsages(projectId: string, accessTokenId: string | null | undefined, serverFarmId: string | null | undefined, usageBeginTime: Date | null | undefined, usageEndTime: Date | null | undefined, recordIndex: number | undefined, recordCount: number | undefined): Promise<DeviceData[]> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/devices/usages?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (accessTokenId !== undefined && accessTokenId !== null)
            url_ += "accessTokenId=" + encodeURIComponent("" + accessTokenId) + "&";
        if (serverFarmId !== undefined && serverFarmId !== null)
            url_ += "serverFarmId=" + encodeURIComponent("" + serverFarmId) + "&";
        if (usageBeginTime !== undefined && usageBeginTime !== null)
            url_ += "usageBeginTime=" + encodeURIComponent(usageBeginTime ? "" + usageBeginTime.toISOString() : "") + "&";
        if (usageEndTime !== undefined && usageEndTime !== null)
            url_ += "usageEndTime=" + encodeURIComponent(usageEndTime ? "" + usageEndTime.toISOString() : "") + "&";
        if (recordIndex === null)
            throw new Error("The parameter 'recordIndex' cannot be null.");
        else if (recordIndex !== undefined)
            url_ += "recordIndex=" + encodeURIComponent("" + recordIndex) + "&";
        if (recordCount === null)
            throw new Error("The parameter 'recordCount' cannot be null.");
        else if (recordCount !== undefined)
            url_ += "recordCount=" + encodeURIComponent("" + recordCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListUsages(_response);
        });
    }

    protected processListUsages(response: Response): Promise<DeviceData[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DeviceData.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeviceData[]>(null as any);
    }
}

export class HealthClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(check: string): Promise<string> {
        let url_ = this.baseUrl + "/api/v1/health/{check}";
        if (check === undefined || check === null)
            throw new Error("The parameter 'check' must be defined.");
        url_ = url_.replace("{check}", encodeURIComponent("" + check));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }
}

export class IpLocksClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    create(projectId: string, createParams: IpLockCreateParams): Promise<IpLock> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/ip-locks";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createParams);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<IpLock> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IpLock.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IpLock>(null as any);
    }

    list(projectId: string, search: string | null | undefined, recordIndex: number | undefined, recordCount: number | undefined): Promise<IpLock[]> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/ip-locks?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (recordIndex === null)
            throw new Error("The parameter 'recordIndex' cannot be null.");
        else if (recordIndex !== undefined)
            url_ += "recordIndex=" + encodeURIComponent("" + recordIndex) + "&";
        if (recordCount === null)
            throw new Error("The parameter 'recordCount' cannot be null.");
        else if (recordCount !== undefined)
            url_ += "recordCount=" + encodeURIComponent("" + recordCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList(_response);
        });
    }

    protected processList(response: Response): Promise<IpLock[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IpLock.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IpLock[]>(null as any);
    }

    update(projectId: string, ip: string, updateParams: IpLockUpdateParams): Promise<IpLock> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/ip-locks/{ip}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (ip === undefined || ip === null)
            throw new Error("The parameter 'ip' must be defined.");
        url_ = url_.replace("{ip}", encodeURIComponent("" + ip));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateParams);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<IpLock> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IpLock.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IpLock>(null as any);
    }

    delete(projectId: string, ip: string): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/ip-locks/{ip}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (ip === undefined || ip === null)
            throw new Error("The parameter 'ip' must be defined.");
        url_ = url_.replace("{ip}", encodeURIComponent("" + ip));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    get(projectId: string, ip: string): Promise<IpLock> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/ip-locks/{ip}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (ip === undefined || ip === null)
            throw new Error("The parameter 'ip' must be defined.");
        url_ = url_.replace("{ip}", encodeURIComponent("" + ip));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<IpLock> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IpLock.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IpLock>(null as any);
    }
}

export class ProjectsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    create(): Promise<Project> {
        let url_ = this.baseUrl + "/api/v1/projects";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<Project> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Project.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Project>(null as any);
    }

    list(search: string | null | undefined, recordIndex: number | undefined, recordCount: number | undefined): Promise<Project[]> {
        let url_ = this.baseUrl + "/api/v1/projects?";
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (recordIndex === null)
            throw new Error("The parameter 'recordIndex' cannot be null.");
        else if (recordIndex !== undefined)
            url_ += "recordIndex=" + encodeURIComponent("" + recordIndex) + "&";
        if (recordCount === null)
            throw new Error("The parameter 'recordCount' cannot be null.");
        else if (recordCount !== undefined)
            url_ += "recordCount=" + encodeURIComponent("" + recordCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList(_response);
        });
    }

    protected processList(response: Response): Promise<Project[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Project.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Project[]>(null as any);
    }

    get(projectId: string): Promise<Project> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<Project> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Project.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Project>(null as any);
    }

    update(projectId: string, updateParams: ProjectUpdateParams): Promise<Project> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateParams);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<Project> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Project.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Project>(null as any);
    }

    getUsage(projectId: string, usageBeginTime: Date | null, usageEndTime: Date | null | undefined, serverFarmId: string | null | undefined, serverId: string | null | undefined): Promise<Usage> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/usage?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (usageBeginTime === undefined)
            throw new Error("The parameter 'usageBeginTime' must be defined.");
        else if(usageBeginTime !== null)
            url_ += "usageBeginTime=" + encodeURIComponent(usageBeginTime ? "" + usageBeginTime.toISOString() : "") + "&";
        if (usageEndTime !== undefined && usageEndTime !== null)
            url_ += "usageEndTime=" + encodeURIComponent(usageEndTime ? "" + usageEndTime.toISOString() : "") + "&";
        if (serverFarmId !== undefined && serverFarmId !== null)
            url_ += "serverFarmId=" + encodeURIComponent("" + serverFarmId) + "&";
        if (serverId !== undefined && serverId !== null)
            url_ += "serverId=" + encodeURIComponent("" + serverId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PATCH",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUsage(_response);
        });
    }

    protected processGetUsage(response: Response): Promise<Usage> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Usage.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Usage>(null as any);
    }
}

export class ServerFarmsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    create(projectId: string, createParams: ServerFarmCreateParams): Promise<ServerFarm> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/server-farms";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createParams);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<ServerFarm> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServerFarm.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ServerFarm>(null as any);
    }

    list(projectId: string, search: string | null | undefined, includeSummary: boolean | undefined, recordIndex: number | undefined, recordCount: number | undefined): Promise<ServerFarmData[]> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/server-farms?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (includeSummary === null)
            throw new Error("The parameter 'includeSummary' cannot be null.");
        else if (includeSummary !== undefined)
            url_ += "includeSummary=" + encodeURIComponent("" + includeSummary) + "&";
        if (recordIndex === null)
            throw new Error("The parameter 'recordIndex' cannot be null.");
        else if (recordIndex !== undefined)
            url_ += "recordIndex=" + encodeURIComponent("" + recordIndex) + "&";
        if (recordCount === null)
            throw new Error("The parameter 'recordCount' cannot be null.");
        else if (recordCount !== undefined)
            url_ += "recordCount=" + encodeURIComponent("" + recordCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList(_response);
        });
    }

    protected processList(response: Response): Promise<ServerFarmData[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ServerFarmData.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ServerFarmData[]>(null as any);
    }

    update(projectId: string, serverFarmId: string, updateParams: ServerFarmUpdateParams): Promise<ServerFarmData> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/server-farms/{serverFarmId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (serverFarmId === undefined || serverFarmId === null)
            throw new Error("The parameter 'serverFarmId' must be defined.");
        url_ = url_.replace("{serverFarmId}", encodeURIComponent("" + serverFarmId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateParams);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<ServerFarmData> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServerFarmData.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ServerFarmData>(null as any);
    }

    get(projectId: string, serverFarmId: string, includeSummary: boolean | undefined): Promise<ServerFarmData> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/server-farms/{serverFarmId}?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (serverFarmId === undefined || serverFarmId === null)
            throw new Error("The parameter 'serverFarmId' must be defined.");
        url_ = url_.replace("{serverFarmId}", encodeURIComponent("" + serverFarmId));
        if (includeSummary === null)
            throw new Error("The parameter 'includeSummary' cannot be null.");
        else if (includeSummary !== undefined)
            url_ += "includeSummary=" + encodeURIComponent("" + includeSummary) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ServerFarmData> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServerFarmData.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ServerFarmData>(null as any);
    }

    delete(projectId: string, serverFarmId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/server-farms/{serverFarmId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (serverFarmId === undefined || serverFarmId === null)
            throw new Error("The parameter 'serverFarmId' must be defined.");
        url_ = url_.replace("{serverFarmId}", encodeURIComponent("" + serverFarmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ServerProfilesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    create(projectId: string, createParams: ServerProfileCreateParams | undefined): Promise<ServerProfile> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/server-profiles";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createParams);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<ServerProfile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServerProfile.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ServerProfile>(null as any);
    }

    list(projectId: string, search: string | null | undefined, includeSummary: boolean | undefined, recordIndex: number | undefined, recordCount: number | undefined): Promise<ServerProfileData[]> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/server-profiles?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (includeSummary === null)
            throw new Error("The parameter 'includeSummary' cannot be null.");
        else if (includeSummary !== undefined)
            url_ += "includeSummary=" + encodeURIComponent("" + includeSummary) + "&";
        if (recordIndex === null)
            throw new Error("The parameter 'recordIndex' cannot be null.");
        else if (recordIndex !== undefined)
            url_ += "recordIndex=" + encodeURIComponent("" + recordIndex) + "&";
        if (recordCount === null)
            throw new Error("The parameter 'recordCount' cannot be null.");
        else if (recordCount !== undefined)
            url_ += "recordCount=" + encodeURIComponent("" + recordCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList(_response);
        });
    }

    protected processList(response: Response): Promise<ServerProfileData[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ServerProfileData.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ServerProfileData[]>(null as any);
    }

    get(projectId: string, serverProfileId: string, includeSummary: boolean | undefined): Promise<ServerProfileData> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/server-profiles/{serverProfileId}?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (serverProfileId === undefined || serverProfileId === null)
            throw new Error("The parameter 'serverProfileId' must be defined.");
        url_ = url_.replace("{serverProfileId}", encodeURIComponent("" + serverProfileId));
        if (includeSummary === null)
            throw new Error("The parameter 'includeSummary' cannot be null.");
        else if (includeSummary !== undefined)
            url_ += "includeSummary=" + encodeURIComponent("" + includeSummary) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ServerProfileData> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServerProfileData.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ServerProfileData>(null as any);
    }

    update(projectId: string, serverProfileId: string, updateParams: ServerProfileUpdateParams): Promise<ServerProfile> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/server-profiles/{serverProfileId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (serverProfileId === undefined || serverProfileId === null)
            throw new Error("The parameter 'serverProfileId' must be defined.");
        url_ = url_.replace("{serverProfileId}", encodeURIComponent("" + serverProfileId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateParams);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<ServerProfile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServerProfile.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ServerProfile>(null as any);
    }

    delete(projectId: string, serverProfileId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/server-profiles/{serverProfileId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (serverProfileId === undefined || serverProfileId === null)
            throw new Error("The parameter 'serverProfileId' must be defined.");
        url_ = url_.replace("{serverProfileId}", encodeURIComponent("" + serverProfileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ServersClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    create(projectId: string, createParams: ServerCreateParams): Promise<VpnServer> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/servers";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createParams);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<VpnServer> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VpnServer.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VpnServer>(null as any);
    }

    list(projectId: string, search: string | null | undefined, serverId: string | null | undefined, serverFarmId: string | null | undefined, recordIndex: number | undefined, recordCount: number | undefined): Promise<ServerData[]> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/servers?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (serverId !== undefined && serverId !== null)
            url_ += "serverId=" + encodeURIComponent("" + serverId) + "&";
        if (serverFarmId !== undefined && serverFarmId !== null)
            url_ += "serverFarmId=" + encodeURIComponent("" + serverFarmId) + "&";
        if (recordIndex === null)
            throw new Error("The parameter 'recordIndex' cannot be null.");
        else if (recordIndex !== undefined)
            url_ += "recordIndex=" + encodeURIComponent("" + recordIndex) + "&";
        if (recordCount === null)
            throw new Error("The parameter 'recordCount' cannot be null.");
        else if (recordCount !== undefined)
            url_ += "recordCount=" + encodeURIComponent("" + recordCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processList(_response);
        });
    }

    protected processList(response: Response): Promise<ServerData[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ServerData.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ServerData[]>(null as any);
    }

    update(projectId: string, serverId: string, updateParams: ServerUpdateParams): Promise<VpnServer> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/servers/{serverId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (serverId === undefined || serverId === null)
            throw new Error("The parameter 'serverId' must be defined.");
        url_ = url_.replace("{serverId}", encodeURIComponent("" + serverId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateParams);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<VpnServer> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VpnServer.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VpnServer>(null as any);
    }

    get(projectId: string, serverId: string): Promise<ServerData> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/servers/{serverId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (serverId === undefined || serverId === null)
            throw new Error("The parameter 'serverId' must be defined.");
        url_ = url_.replace("{serverId}", encodeURIComponent("" + serverId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ServerData> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServerData.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ServerData>(null as any);
    }

    delete(projectId: string, serverId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/servers/{serverId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (serverId === undefined || serverId === null)
            throw new Error("The parameter 'serverId' must be defined.");
        url_ = url_.replace("{serverId}", encodeURIComponent("" + serverId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    reconfigure(projectId: string, serverId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/servers/{serverId}/reconfigure";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (serverId === undefined || serverId === null)
            throw new Error("The parameter 'serverId' must be defined.");
        url_ = url_.replace("{serverId}", encodeURIComponent("" + serverId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReconfigure(_response);
        });
    }

    protected processReconfigure(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    installBySshUserPassword(projectId: string, serverId: string, installParams: ServerInstallBySshUserPasswordParams): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/servers/{serverId}/install-by-ssh-user-password";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (serverId === undefined || serverId === null)
            throw new Error("The parameter 'serverId' must be defined.");
        url_ = url_.replace("{serverId}", encodeURIComponent("" + serverId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(installParams);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInstallBySshUserPassword(_response);
        });
    }

    protected processInstallBySshUserPassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    installBySshUserKey(projectId: string, serverId: string, installParams: ServerInstallBySshUserKeyParams): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/servers/{serverId}/install-by-ssh-user-key";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (serverId === undefined || serverId === null)
            throw new Error("The parameter 'serverId' must be defined.");
        url_ = url_.replace("{serverId}", encodeURIComponent("" + serverId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(installParams);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInstallBySshUserKey(_response);
        });
    }

    protected processInstallBySshUserKey(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    getInstallManual(projectId: string, serverId: string): Promise<ServerInstallManual> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/servers/{serverId}/install/manual";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (serverId === undefined || serverId === null)
            throw new Error("The parameter 'serverId' must be defined.");
        url_ = url_.replace("{serverId}", encodeURIComponent("" + serverId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetInstallManual(_response);
        });
    }

    protected processGetInstallManual(response: Response): Promise<ServerInstallManual> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServerInstallManual.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ServerInstallManual>(null as any);
    }

    getStatusSummary(projectId: string, serverFarmId: string | null | undefined): Promise<ServersStatusSummary> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/servers/status-summary?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (serverFarmId !== undefined && serverFarmId !== null)
            url_ += "serverFarmId=" + encodeURIComponent("" + serverFarmId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStatusSummary(_response);
        });
    }

    protected processGetStatusSummary(response: Response): Promise<ServersStatusSummary> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ServersStatusSummary.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ServersStatusSummary>(null as any);
    }

    getStatusHistory(projectId: string, usageBeginTime: Date | null, usageEndTime: Date | null | undefined, serverId: string | null | undefined): Promise<ServerStatusHistory[]> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/servers/status-history?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (usageBeginTime === undefined)
            throw new Error("The parameter 'usageBeginTime' must be defined.");
        else if(usageBeginTime !== null)
            url_ += "usageBeginTime=" + encodeURIComponent(usageBeginTime ? "" + usageBeginTime.toISOString() : "") + "&";
        if (usageEndTime !== undefined && usageEndTime !== null)
            url_ += "usageEndTime=" + encodeURIComponent(usageEndTime ? "" + usageEndTime.toISOString() : "") + "&";
        if (serverId !== undefined && serverId !== null)
            url_ += "serverId=" + encodeURIComponent("" + serverId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStatusHistory(_response);
        });
    }

    protected processGetStatusHistory(response: Response): Promise<ServerStatusHistory[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ServerStatusHistory.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ServerStatusHistory[]>(null as any);
    }
}

export class SystemClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    sync(): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/system";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSync(_response);
        });
    }

    protected processSync(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class TeamClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    listCurrentUserProjects(): Promise<Project[]> {
        let url_ = this.baseUrl + "/api/v1/team/users/current/projects";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListCurrentUserProjects(_response);
        });
    }

    protected processListCurrentUserProjects(response: Response): Promise<Project[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Project.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Project[]>(null as any);
    }

    listCurrentUserResources(): Promise<string[]> {
        let url_ = this.baseUrl + "/api/v1/team/users/current/resources";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListCurrentUserResources(_response);
        });
    }

    protected processListCurrentUserResources(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    listCurrentUserPermissions(resourceId: string): Promise<string[]> {
        let url_ = this.baseUrl + "/api/v1/team/users/current/resources/{resourceId}/permissions";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListCurrentUserPermissions(_response);
        });
    }

    protected processListCurrentUserPermissions(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    resetBotApiKey(userId: string): Promise<ApiKey> {
        let url_ = this.baseUrl + "/api/v1/team/users/{userId}/bot/reset-api-key";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResetBotApiKey(_response);
        });
    }

    protected processResetBotApiKey(response: Response): Promise<ApiKey> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiKey.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiKey>(null as any);
    }

    updateBot(userId: string, updateParam: TeamUpdateBotParam): Promise<User> {
        let url_ = this.baseUrl + "/api/v1/team/users/{userId}/bot";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateParam);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateBot(_response);
        });
    }

    protected processUpdateBot(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User>(null as any);
    }

    listRoles(resourceId: string): Promise<Role[]> {
        let url_ = this.baseUrl + "/api/v1/team/resources/{resourceId}/roles";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListRoles(_response);
        });
    }

    protected processListRoles(response: Response): Promise<Role[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Role.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Role[]>(null as any);
    }

    listUserRoles(resourceId: string, roleId: string | null | undefined, userId: string | null | undefined, search: string | null | undefined, isBot: boolean | null | undefined, recordIndex: number | undefined, recordCount: number | null | undefined): Promise<ListResultOfUserRole> {
        let url_ = this.baseUrl + "/api/v1/team/resources/{resourceId}/user-roles?";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        if (roleId !== undefined && roleId !== null)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (isBot !== undefined && isBot !== null)
            url_ += "isBot=" + encodeURIComponent("" + isBot) + "&";
        if (recordIndex === null)
            throw new Error("The parameter 'recordIndex' cannot be null.");
        else if (recordIndex !== undefined)
            url_ += "recordIndex=" + encodeURIComponent("" + recordIndex) + "&";
        if (recordCount !== undefined && recordCount !== null)
            url_ += "recordCount=" + encodeURIComponent("" + recordCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListUserRoles(_response);
        });
    }

    protected processListUserRoles(response: Response): Promise<ListResultOfUserRole> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultOfUserRole.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListResultOfUserRole>(null as any);
    }

    addNewBot(resourceId: string, roleId: string, addParam: TeamAddBotParam): Promise<ApiKey> {
        let url_ = this.baseUrl + "/api/v1/team/resources/{resourceId}/roles/{roleId}/bots";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(addParam);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddNewBot(_response);
        });
    }

    protected processAddNewBot(response: Response): Promise<ApiKey> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiKey.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiKey>(null as any);
    }

    addUserByEmail(resourceId: string, roleId: string, email: string, addParam: TeamAddEmailParam | undefined): Promise<UserRole> {
        let url_ = this.baseUrl + "/api/v1/team/resources/{resourceId}/roles/{roleId}/users/email:{email}";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined.");
        url_ = url_.replace("{email}", encodeURIComponent("" + email));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(addParam);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddUserByEmail(_response);
        });
    }

    protected processAddUserByEmail(response: Response): Promise<UserRole> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserRole.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserRole>(null as any);
    }

    addUser(resourceId: string, roleId: string, userId: string): Promise<UserRole> {
        let url_ = this.baseUrl + "/api/v1/team/resources/{resourceId}/roles/{roleId}/users/{userId}";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddUser(_response);
        });
    }

    protected processAddUser(response: Response): Promise<UserRole> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserRole.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserRole>(null as any);
    }

    removeUser(resourceId: string, roleId: string, userId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/team/resources/{resourceId}/roles/{roleId}/users/{userId}";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveUser(_response);
        });
    }

    protected processRemoveUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    createSystemApiKey(): Promise<ApiKey> {
        let url_ = this.baseUrl + "/api/v1/team/system/api-key";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateSystemApiKey(_response);
        });
    }

    protected processCreateSystemApiKey(response: Response): Promise<ApiKey> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiKey.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiKey>(null as any);
    }
}

export class AuthenticationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getCurrentUser(): Promise<User> {
        let url_ = this.baseUrl + "/api/v1/authentication/current";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCurrentUser(_response);
        });
    }

    protected processGetCurrentUser(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User>(null as any);
    }

    signOutAll(): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/authentication/current/signout-all";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSignOutAll(_response);
        });
    }

    protected processSignOutAll(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    resetCurrentUserApiKey(): Promise<ApiKey> {
        let url_ = this.baseUrl + "/api/v1/authentication/current/reset-api-key";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResetCurrentUserApiKey(_response);
        });
    }

    protected processResetCurrentUserApiKey(response: Response): Promise<ApiKey> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiKey.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiKey>(null as any);
    }

    signIn(request: SignInRequest): Promise<ApiKey> {
        let url_ = this.baseUrl + "/api/v1/authentication/signin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSignIn(_response);
        });
    }

    protected processSignIn(response: Response): Promise<ApiKey> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiKey.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiKey>(null as any);
    }

    signUp(request: SignUpRequest): Promise<ApiKey> {
        let url_ = this.baseUrl + "/api/v1/authentication/signup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSignUp(_response);
        });
    }

    protected processSignUp(response: Response): Promise<ApiKey> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiKey.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiKey>(null as any);
    }

    refreshToken(request: RefreshTokenRequest): Promise<ApiKey> {
        let url_ = this.baseUrl + "/api/v1/authentication/refresh-token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRefreshToken(_response);
        });
    }

    protected processRefreshToken(response: Response): Promise<ApiKey> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiKey.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiKey>(null as any);
    }

    googleSignInHandler(): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/v1/authentication/external/google/signin-handler";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGoogleSignInHandler(_response);
        });
    }

    protected processGoogleSignInHandler(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    getGoogleSignInUrl(csrfToken: string, nonce: string | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/v1/authentication/external/google/signin-url?";
        if (csrfToken === undefined || csrfToken === null)
            throw new Error("The parameter 'csrfToken' must be defined and cannot be null.");
        else
            url_ += "csrfToken=" + encodeURIComponent("" + csrfToken) + "&";
        if (nonce !== undefined && nonce !== null)
            url_ += "nonce=" + encodeURIComponent("" + nonce) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetGoogleSignInUrl(_response);
        });
    }

    protected processGetGoogleSignInUrl(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }
}

export class AccessData implements IAccessData {
    access!: Access;
    accessToken!: AccessToken;
    device?: Device | undefined;

    constructor(data?: IAccessData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.access = new Access();
            this.accessToken = new AccessToken();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.access = _data["access"] ? Access.fromJS(_data["access"]) : new Access();
            this.accessToken = _data["accessToken"] ? AccessToken.fromJS(_data["accessToken"]) : new AccessToken();
            this.device = _data["device"] ? Device.fromJS(_data["device"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AccessData {
        data = typeof data === 'object' ? data : {};
        let result = new AccessData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["access"] = this.access ? this.access.toJSON() : <any>undefined;
        data["accessToken"] = this.accessToken ? this.accessToken.toJSON() : <any>undefined;
        data["device"] = this.device ? this.device.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAccessData {
    access: Access;
    accessToken: AccessToken;
    device?: Device | undefined;
}

export class Access implements IAccess {
    accessId!: string;
    accessTokenId!: string;
    endTime?: Date | undefined;
    lockedTime?: Date | undefined;
    createdTime!: Date;
    lastUsedTime!: Date;
    description?: string | undefined;
    cycleSentTraffic!: number;
    cycleReceivedTraffic!: number;
    cycleTraffic!: number;
    totalSentTraffic!: number;
    totalReceivedTraffic!: number;
    totalTraffic!: number;

    constructor(data?: IAccess) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessId = _data["accessId"];
            this.accessTokenId = _data["accessTokenId"];
            this.endTime = _data["endTime"] ? new Date(_data["endTime"].toString()) : <any>undefined;
            this.lockedTime = _data["lockedTime"] ? new Date(_data["lockedTime"].toString()) : <any>undefined;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>undefined;
            this.lastUsedTime = _data["lastUsedTime"] ? new Date(_data["lastUsedTime"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.cycleSentTraffic = _data["cycleSentTraffic"];
            this.cycleReceivedTraffic = _data["cycleReceivedTraffic"];
            this.cycleTraffic = _data["cycleTraffic"];
            this.totalSentTraffic = _data["totalSentTraffic"];
            this.totalReceivedTraffic = _data["totalReceivedTraffic"];
            this.totalTraffic = _data["totalTraffic"];
        }
    }

    static fromJS(data: any): Access {
        data = typeof data === 'object' ? data : {};
        let result = new Access();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessId"] = this.accessId;
        data["accessTokenId"] = this.accessTokenId;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["lockedTime"] = this.lockedTime ? this.lockedTime.toISOString() : <any>undefined;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>undefined;
        data["lastUsedTime"] = this.lastUsedTime ? this.lastUsedTime.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["cycleSentTraffic"] = this.cycleSentTraffic;
        data["cycleReceivedTraffic"] = this.cycleReceivedTraffic;
        data["cycleTraffic"] = this.cycleTraffic;
        data["totalSentTraffic"] = this.totalSentTraffic;
        data["totalReceivedTraffic"] = this.totalReceivedTraffic;
        data["totalTraffic"] = this.totalTraffic;
        return data;
    }
}

export interface IAccess {
    accessId: string;
    accessTokenId: string;
    endTime?: Date | undefined;
    lockedTime?: Date | undefined;
    createdTime: Date;
    lastUsedTime: Date;
    description?: string | undefined;
    cycleSentTraffic: number;
    cycleReceivedTraffic: number;
    cycleTraffic: number;
    totalSentTraffic: number;
    totalReceivedTraffic: number;
    totalTraffic: number;
}

export class AccessToken implements IAccessToken {
    projectId!: string;
    accessTokenId!: string;
    accessTokenName?: string | undefined;
    supportCode!: number;
    serverFarmId!: string;
    serverFarmName?: string | undefined;
    maxTraffic!: number;
    lifetime!: number;
    maxDevice!: number;
    firstUsedTime?: Date | undefined;
    lastUsedTime?: Date | undefined;
    url?: string | undefined;
    isPublic!: boolean;
    isEnabled!: boolean;
    expirationTime?: Date | undefined;
    createdTime!: Date;
    modifiedTime!: Date;

    constructor(data?: IAccessToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectId = _data["projectId"];
            this.accessTokenId = _data["accessTokenId"];
            this.accessTokenName = _data["accessTokenName"];
            this.supportCode = _data["supportCode"];
            this.serverFarmId = _data["serverFarmId"];
            this.serverFarmName = _data["serverFarmName"];
            this.maxTraffic = _data["maxTraffic"];
            this.lifetime = _data["lifetime"];
            this.maxDevice = _data["maxDevice"];
            this.firstUsedTime = _data["firstUsedTime"] ? new Date(_data["firstUsedTime"].toString()) : <any>undefined;
            this.lastUsedTime = _data["lastUsedTime"] ? new Date(_data["lastUsedTime"].toString()) : <any>undefined;
            this.url = _data["url"];
            this.isPublic = _data["isPublic"];
            this.isEnabled = _data["isEnabled"];
            this.expirationTime = _data["expirationTime"] ? new Date(_data["expirationTime"].toString()) : <any>undefined;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>undefined;
            this.modifiedTime = _data["modifiedTime"] ? new Date(_data["modifiedTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AccessToken {
        data = typeof data === 'object' ? data : {};
        let result = new AccessToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["accessTokenId"] = this.accessTokenId;
        data["accessTokenName"] = this.accessTokenName;
        data["supportCode"] = this.supportCode;
        data["serverFarmId"] = this.serverFarmId;
        data["serverFarmName"] = this.serverFarmName;
        data["maxTraffic"] = this.maxTraffic;
        data["lifetime"] = this.lifetime;
        data["maxDevice"] = this.maxDevice;
        data["firstUsedTime"] = this.firstUsedTime ? this.firstUsedTime.toISOString() : <any>undefined;
        data["lastUsedTime"] = this.lastUsedTime ? this.lastUsedTime.toISOString() : <any>undefined;
        data["url"] = this.url;
        data["isPublic"] = this.isPublic;
        data["isEnabled"] = this.isEnabled;
        data["expirationTime"] = this.expirationTime ? this.expirationTime.toISOString() : <any>undefined;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>undefined;
        data["modifiedTime"] = this.modifiedTime ? this.modifiedTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IAccessToken {
    projectId: string;
    accessTokenId: string;
    accessTokenName?: string | undefined;
    supportCode: number;
    serverFarmId: string;
    serverFarmName?: string | undefined;
    maxTraffic: number;
    lifetime: number;
    maxDevice: number;
    firstUsedTime?: Date | undefined;
    lastUsedTime?: Date | undefined;
    url?: string | undefined;
    isPublic: boolean;
    isEnabled: boolean;
    expirationTime?: Date | undefined;
    createdTime: Date;
    modifiedTime: Date;
}

export class Device implements IDevice {
    deviceId!: string;
    clientId!: string;
    clientVersion?: string | undefined;
    ipAddress?: string | undefined;
    country?: string | undefined;
    userAgent?: string | undefined;
    createdTime!: Date;
    modifiedTime!: Date;
    lockedTime?: Date | undefined;
    osName!: string;

    constructor(data?: IDevice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.clientId = _data["clientId"];
            this.clientVersion = _data["clientVersion"];
            this.ipAddress = _data["ipAddress"];
            this.country = _data["country"];
            this.userAgent = _data["userAgent"];
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>undefined;
            this.modifiedTime = _data["modifiedTime"] ? new Date(_data["modifiedTime"].toString()) : <any>undefined;
            this.lockedTime = _data["lockedTime"] ? new Date(_data["lockedTime"].toString()) : <any>undefined;
            this.osName = _data["osName"];
        }
    }

    static fromJS(data: any): Device {
        data = typeof data === 'object' ? data : {};
        let result = new Device();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["clientId"] = this.clientId;
        data["clientVersion"] = this.clientVersion;
        data["ipAddress"] = this.ipAddress;
        data["country"] = this.country;
        data["userAgent"] = this.userAgent;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>undefined;
        data["modifiedTime"] = this.modifiedTime ? this.modifiedTime.toISOString() : <any>undefined;
        data["lockedTime"] = this.lockedTime ? this.lockedTime.toISOString() : <any>undefined;
        data["osName"] = this.osName;
        return data;
    }
}

export interface IDevice {
    deviceId: string;
    clientId: string;
    clientVersion?: string | undefined;
    ipAddress?: string | undefined;
    country?: string | undefined;
    userAgent?: string | undefined;
    createdTime: Date;
    modifiedTime: Date;
    lockedTime?: Date | undefined;
    osName: string;
}

export class ListResultOfAccessData implements IListResultOfAccessData {
    totalCount?: number | undefined;
    items!: AccessData[];

    constructor(data?: IListResultOfAccessData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AccessData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultOfAccessData {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultOfAccessData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultOfAccessData {
    totalCount?: number | undefined;
    items: AccessData[];
}

export class AccessTokenCreateParams implements IAccessTokenCreateParams {
    accessTokenId?: string | undefined;
    serverFarmId!: string;
    accessTokenName?: string | undefined;
    secret?: string | undefined;
    maxTraffic!: number;
    lifetime!: number;
    maxDevice!: number;
    expirationTime?: Date | undefined;
    url?: string | undefined;
    isPublic!: boolean;

    constructor(data?: IAccessTokenCreateParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessTokenId = _data["accessTokenId"];
            this.serverFarmId = _data["serverFarmId"];
            this.accessTokenName = _data["accessTokenName"];
            this.secret = _data["secret"];
            this.maxTraffic = _data["maxTraffic"];
            this.lifetime = _data["lifetime"];
            this.maxDevice = _data["maxDevice"];
            this.expirationTime = _data["expirationTime"] ? new Date(_data["expirationTime"].toString()) : <any>undefined;
            this.url = _data["url"];
            this.isPublic = _data["isPublic"];
        }
    }

    static fromJS(data: any): AccessTokenCreateParams {
        data = typeof data === 'object' ? data : {};
        let result = new AccessTokenCreateParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessTokenId"] = this.accessTokenId;
        data["serverFarmId"] = this.serverFarmId;
        data["accessTokenName"] = this.accessTokenName;
        data["secret"] = this.secret;
        data["maxTraffic"] = this.maxTraffic;
        data["lifetime"] = this.lifetime;
        data["maxDevice"] = this.maxDevice;
        data["expirationTime"] = this.expirationTime ? this.expirationTime.toISOString() : <any>undefined;
        data["url"] = this.url;
        data["isPublic"] = this.isPublic;
        return data;
    }
}

export interface IAccessTokenCreateParams {
    accessTokenId?: string | undefined;
    serverFarmId: string;
    accessTokenName?: string | undefined;
    secret?: string | undefined;
    maxTraffic: number;
    lifetime: number;
    maxDevice: number;
    expirationTime?: Date | undefined;
    url?: string | undefined;
    isPublic: boolean;
}

export class AccessTokenUpdateParams implements IAccessTokenUpdateParams {
    accessTokenName?: PatchOfString | undefined;
    serverFarmId?: PatchOfGuid | undefined;
    expirationTime?: PatchOfNullableDateTime | undefined;
    lifetime?: PatchOfInteger | undefined;
    maxDevice?: PatchOfInteger | undefined;
    maxTraffic?: PatchOfLong | undefined;
    url?: PatchOfString | undefined;
    isEnabled?: PatchOfBoolean | undefined;

    constructor(data?: IAccessTokenUpdateParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessTokenName = _data["accessTokenName"] ? PatchOfString.fromJS(_data["accessTokenName"]) : <any>undefined;
            this.serverFarmId = _data["serverFarmId"] ? PatchOfGuid.fromJS(_data["serverFarmId"]) : <any>undefined;
            this.expirationTime = _data["expirationTime"] ? PatchOfNullableDateTime.fromJS(_data["expirationTime"]) : <any>undefined;
            this.lifetime = _data["lifetime"] ? PatchOfInteger.fromJS(_data["lifetime"]) : <any>undefined;
            this.maxDevice = _data["maxDevice"] ? PatchOfInteger.fromJS(_data["maxDevice"]) : <any>undefined;
            this.maxTraffic = _data["maxTraffic"] ? PatchOfLong.fromJS(_data["maxTraffic"]) : <any>undefined;
            this.url = _data["url"] ? PatchOfString.fromJS(_data["url"]) : <any>undefined;
            this.isEnabled = _data["isEnabled"] ? PatchOfBoolean.fromJS(_data["isEnabled"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AccessTokenUpdateParams {
        data = typeof data === 'object' ? data : {};
        let result = new AccessTokenUpdateParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessTokenName"] = this.accessTokenName ? this.accessTokenName.toJSON() : <any>undefined;
        data["serverFarmId"] = this.serverFarmId ? this.serverFarmId.toJSON() : <any>undefined;
        data["expirationTime"] = this.expirationTime ? this.expirationTime.toJSON() : <any>undefined;
        data["lifetime"] = this.lifetime ? this.lifetime.toJSON() : <any>undefined;
        data["maxDevice"] = this.maxDevice ? this.maxDevice.toJSON() : <any>undefined;
        data["maxTraffic"] = this.maxTraffic ? this.maxTraffic.toJSON() : <any>undefined;
        data["url"] = this.url ? this.url.toJSON() : <any>undefined;
        data["isEnabled"] = this.isEnabled ? this.isEnabled.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAccessTokenUpdateParams {
    accessTokenName?: PatchOfString | undefined;
    serverFarmId?: PatchOfGuid | undefined;
    expirationTime?: PatchOfNullableDateTime | undefined;
    lifetime?: PatchOfInteger | undefined;
    maxDevice?: PatchOfInteger | undefined;
    maxTraffic?: PatchOfLong | undefined;
    url?: PatchOfString | undefined;
    isEnabled?: PatchOfBoolean | undefined;
}

export class PatchOfString implements IPatchOfString {
    value!: string;

    constructor(data?: IPatchOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): PatchOfString {
        data = typeof data === 'object' ? data : {};
        let result = new PatchOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        return data;
    }
}

export interface IPatchOfString {
    value: string;
}

export class PatchOfGuid implements IPatchOfGuid {
    value!: string;

    constructor(data?: IPatchOfGuid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): PatchOfGuid {
        data = typeof data === 'object' ? data : {};
        let result = new PatchOfGuid();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        return data;
    }
}

export interface IPatchOfGuid {
    value: string;
}

export class PatchOfNullableDateTime implements IPatchOfNullableDateTime {
    value?: Date | undefined;

    constructor(data?: IPatchOfNullableDateTime) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] ? new Date(_data["value"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PatchOfNullableDateTime {
        data = typeof data === 'object' ? data : {};
        let result = new PatchOfNullableDateTime();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? this.value.toISOString() : <any>undefined;
        return data;
    }
}

export interface IPatchOfNullableDateTime {
    value?: Date | undefined;
}

export class PatchOfInteger implements IPatchOfInteger {
    value!: number;

    constructor(data?: IPatchOfInteger) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): PatchOfInteger {
        data = typeof data === 'object' ? data : {};
        let result = new PatchOfInteger();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        return data;
    }
}

export interface IPatchOfInteger {
    value: number;
}

export class PatchOfLong implements IPatchOfLong {
    value!: number;

    constructor(data?: IPatchOfLong) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): PatchOfLong {
        data = typeof data === 'object' ? data : {};
        let result = new PatchOfLong();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        return data;
    }
}

export interface IPatchOfLong {
    value: number;
}

export class PatchOfBoolean implements IPatchOfBoolean {
    value!: boolean;

    constructor(data?: IPatchOfBoolean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): PatchOfBoolean {
        data = typeof data === 'object' ? data : {};
        let result = new PatchOfBoolean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        return data;
    }
}

export interface IPatchOfBoolean {
    value: boolean;
}

export class AccessTokenData implements IAccessTokenData {
    accessToken!: AccessToken;
    usage?: Usage | undefined;
    access?: Access | undefined;

    constructor(data?: IAccessTokenData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.accessToken = new AccessToken();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"] ? AccessToken.fromJS(_data["accessToken"]) : new AccessToken();
            this.usage = _data["usage"] ? Usage.fromJS(_data["usage"]) : <any>undefined;
            this.access = _data["access"] ? Access.fromJS(_data["access"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AccessTokenData {
        data = typeof data === 'object' ? data : {};
        let result = new AccessTokenData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken ? this.accessToken.toJSON() : <any>undefined;
        data["usage"] = this.usage ? this.usage.toJSON() : <any>undefined;
        data["access"] = this.access ? this.access.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAccessTokenData {
    accessToken: AccessToken;
    usage?: Usage | undefined;
    access?: Access | undefined;
}

export class Usage implements IUsage {
    sentTraffic!: number;
    receivedTraffic!: number;
    deviceCount?: number | undefined;
    serverCount?: number | undefined;
    sessionCount?: number | undefined;
    accessTokenCount?: number | undefined;
    countryCount?: number | undefined;

    constructor(data?: IUsage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sentTraffic = _data["sentTraffic"];
            this.receivedTraffic = _data["receivedTraffic"];
            this.deviceCount = _data["deviceCount"];
            this.serverCount = _data["serverCount"];
            this.sessionCount = _data["sessionCount"];
            this.accessTokenCount = _data["accessTokenCount"];
            this.countryCount = _data["countryCount"];
        }
    }

    static fromJS(data: any): Usage {
        data = typeof data === 'object' ? data : {};
        let result = new Usage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sentTraffic"] = this.sentTraffic;
        data["receivedTraffic"] = this.receivedTraffic;
        data["deviceCount"] = this.deviceCount;
        data["serverCount"] = this.serverCount;
        data["sessionCount"] = this.sessionCount;
        data["accessTokenCount"] = this.accessTokenCount;
        data["countryCount"] = this.countryCount;
        return data;
    }
}

export interface IUsage {
    sentTraffic: number;
    receivedTraffic: number;
    deviceCount?: number | undefined;
    serverCount?: number | undefined;
    sessionCount?: number | undefined;
    accessTokenCount?: number | undefined;
    countryCount?: number | undefined;
}

export class ListResultOfAccessTokenData implements IListResultOfAccessTokenData {
    totalCount?: number | undefined;
    items!: AccessTokenData[];

    constructor(data?: IListResultOfAccessTokenData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AccessTokenData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultOfAccessTokenData {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultOfAccessTokenData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultOfAccessTokenData {
    totalCount?: number | undefined;
    items: AccessTokenData[];
}

export class Certificate implements ICertificate {
    certificateId!: string;
    commonName!: string;
    issueTime?: Date | undefined;
    expirationTime!: Date;
    createdTime!: Date;
    isVerified!: boolean;
    thumbprint?: string | undefined;
    rawData?: string | undefined;

    constructor(data?: ICertificate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.certificateId = _data["certificateId"];
            this.commonName = _data["commonName"];
            this.issueTime = _data["issueTime"] ? new Date(_data["issueTime"].toString()) : <any>undefined;
            this.expirationTime = _data["expirationTime"] ? new Date(_data["expirationTime"].toString()) : <any>undefined;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>undefined;
            this.isVerified = _data["isVerified"];
            this.thumbprint = _data["thumbprint"];
            this.rawData = _data["rawData"];
        }
    }

    static fromJS(data: any): Certificate {
        data = typeof data === 'object' ? data : {};
        let result = new Certificate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["certificateId"] = this.certificateId;
        data["commonName"] = this.commonName;
        data["issueTime"] = this.issueTime ? this.issueTime.toISOString() : <any>undefined;
        data["expirationTime"] = this.expirationTime ? this.expirationTime.toISOString() : <any>undefined;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>undefined;
        data["isVerified"] = this.isVerified;
        data["thumbprint"] = this.thumbprint;
        data["rawData"] = this.rawData;
        return data;
    }
}

export interface ICertificate {
    certificateId: string;
    commonName: string;
    issueTime?: Date | undefined;
    expirationTime: Date;
    createdTime: Date;
    isVerified: boolean;
    thumbprint?: string | undefined;
    rawData?: string | undefined;
}

export class CertificateSelfSignedParams implements ICertificateSelfSignedParams {
    subjectName?: string | undefined;
    expirationTime?: Date | undefined;

    constructor(data?: ICertificateSelfSignedParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subjectName = _data["subjectName"];
            this.expirationTime = _data["expirationTime"] ? new Date(_data["expirationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CertificateSelfSignedParams {
        data = typeof data === 'object' ? data : {};
        let result = new CertificateSelfSignedParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subjectName"] = this.subjectName;
        data["expirationTime"] = this.expirationTime ? this.expirationTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICertificateSelfSignedParams {
    subjectName?: string | undefined;
    expirationTime?: Date | undefined;
}

export class CertificateImportParams implements ICertificateImportParams {
    rawData!: string;
    password?: string | undefined;

    constructor(data?: ICertificateImportParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rawData = _data["rawData"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): CertificateImportParams {
        data = typeof data === 'object' ? data : {};
        let result = new CertificateImportParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rawData"] = this.rawData;
        data["password"] = this.password;
        return data;
    }
}

export interface ICertificateImportParams {
    rawData: string;
    password?: string | undefined;
}

export class CertificateData implements ICertificateData {
    certificate!: Certificate;
    serverFarms?: IdNameOfGuid[] | undefined;
    summary?: CertificateSummary | undefined;

    constructor(data?: ICertificateData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.certificate = new Certificate();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.certificate = _data["certificate"] ? Certificate.fromJS(_data["certificate"]) : new Certificate();
            if (Array.isArray(_data["serverFarms"])) {
                this.serverFarms = [] as any;
                for (let item of _data["serverFarms"])
                    this.serverFarms!.push(IdNameOfGuid.fromJS(item));
            }
            this.summary = _data["summary"] ? CertificateSummary.fromJS(_data["summary"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CertificateData {
        data = typeof data === 'object' ? data : {};
        let result = new CertificateData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["certificate"] = this.certificate ? this.certificate.toJSON() : <any>undefined;
        if (Array.isArray(this.serverFarms)) {
            data["serverFarms"] = [];
            for (let item of this.serverFarms)
                data["serverFarms"].push(item.toJSON());
        }
        data["summary"] = this.summary ? this.summary.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICertificateData {
    certificate: Certificate;
    serverFarms?: IdNameOfGuid[] | undefined;
    summary?: CertificateSummary | undefined;
}

export class IdNameOfGuid implements IIdNameOfGuid {
    id!: string;
    name!: string;

    constructor(data?: IIdNameOfGuid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): IdNameOfGuid {
        data = typeof data === 'object' ? data : {};
        let result = new IdNameOfGuid();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IIdNameOfGuid {
    id: string;
    name: string;
}

export class CertificateSummary implements ICertificateSummary {
    serverFarmCount!: number;

    constructor(data?: ICertificateSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serverFarmCount = _data["serverFarmCount"];
        }
    }

    static fromJS(data: any): CertificateSummary {
        data = typeof data === 'object' ? data : {};
        let result = new CertificateSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverFarmCount"] = this.serverFarmCount;
        return data;
    }
}

export interface ICertificateSummary {
    serverFarmCount: number;
}

export class DeviceData implements IDeviceData {
    device!: Device;
    usage?: TrafficUsage | undefined;

    constructor(data?: IDeviceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.device = new Device();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.device = _data["device"] ? Device.fromJS(_data["device"]) : new Device();
            this.usage = _data["usage"] ? TrafficUsage.fromJS(_data["usage"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DeviceData {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["device"] = this.device ? this.device.toJSON() : <any>undefined;
        data["usage"] = this.usage ? this.usage.toJSON() : <any>undefined;
        return data;
    }
}

export interface IDeviceData {
    device: Device;
    usage?: TrafficUsage | undefined;
}

export class TrafficUsage implements ITrafficUsage {
    sentTraffic!: number;
    receivedTraffic!: number;
    lastUsedTime!: Date;

    constructor(data?: ITrafficUsage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sentTraffic = _data["sentTraffic"];
            this.receivedTraffic = _data["receivedTraffic"];
            this.lastUsedTime = _data["lastUsedTime"] ? new Date(_data["lastUsedTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TrafficUsage {
        data = typeof data === 'object' ? data : {};
        let result = new TrafficUsage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sentTraffic"] = this.sentTraffic;
        data["receivedTraffic"] = this.receivedTraffic;
        data["lastUsedTime"] = this.lastUsedTime ? this.lastUsedTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface ITrafficUsage {
    sentTraffic: number;
    receivedTraffic: number;
    lastUsedTime: Date;
}

export class DeviceUpdateParams implements IDeviceUpdateParams {
    isLocked?: PatchOfBoolean | undefined;

    constructor(data?: IDeviceUpdateParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isLocked = _data["isLocked"] ? PatchOfBoolean.fromJS(_data["isLocked"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DeviceUpdateParams {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceUpdateParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLocked"] = this.isLocked ? this.isLocked.toJSON() : <any>undefined;
        return data;
    }
}

export interface IDeviceUpdateParams {
    isLocked?: PatchOfBoolean | undefined;
}

export class IpLock implements IIpLock {
    ipAddress!: string;
    lockedTime?: Date | undefined;
    description?: string | undefined;

    constructor(data?: IIpLock) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ipAddress = _data["ipAddress"];
            this.lockedTime = _data["lockedTime"] ? new Date(_data["lockedTime"].toString()) : <any>undefined;
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): IpLock {
        data = typeof data === 'object' ? data : {};
        let result = new IpLock();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ipAddress"] = this.ipAddress;
        data["lockedTime"] = this.lockedTime ? this.lockedTime.toISOString() : <any>undefined;
        data["description"] = this.description;
        return data;
    }
}

export interface IIpLock {
    ipAddress: string;
    lockedTime?: Date | undefined;
    description?: string | undefined;
}

export class IpLockCreateParams implements IIpLockCreateParams {
    ipAddress!: string;
    isLocked!: boolean;
    description?: string | undefined;

    constructor(data?: IIpLockCreateParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ipAddress = _data["ipAddress"];
            this.isLocked = _data["isLocked"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): IpLockCreateParams {
        data = typeof data === 'object' ? data : {};
        let result = new IpLockCreateParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ipAddress"] = this.ipAddress;
        data["isLocked"] = this.isLocked;
        data["description"] = this.description;
        return data;
    }
}

export interface IIpLockCreateParams {
    ipAddress: string;
    isLocked: boolean;
    description?: string | undefined;
}

export class IpLockUpdateParams implements IIpLockUpdateParams {
    isLocked?: PatchOfBoolean | undefined;
    description?: PatchOfString | undefined;

    constructor(data?: IIpLockUpdateParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isLocked = _data["isLocked"] ? PatchOfBoolean.fromJS(_data["isLocked"]) : <any>undefined;
            this.description = _data["description"] ? PatchOfString.fromJS(_data["description"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IpLockUpdateParams {
        data = typeof data === 'object' ? data : {};
        let result = new IpLockUpdateParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLocked"] = this.isLocked ? this.isLocked.toJSON() : <any>undefined;
        data["description"] = this.description ? this.description.toJSON() : <any>undefined;
        return data;
    }
}

export interface IIpLockUpdateParams {
    isLocked?: PatchOfBoolean | undefined;
    description?: PatchOfString | undefined;
}

export class Project implements IProject {
    projectId!: string;
    projectName?: string | undefined;
    createdTime!: Date;
    subscriptionType!: SubscriptionType;
    gaMeasurementId?: string | undefined;
    gaApiSecret?: string | undefined;

    constructor(data?: IProject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectId = _data["projectId"];
            this.projectName = _data["projectName"];
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>undefined;
            this.subscriptionType = _data["subscriptionType"];
            this.gaMeasurementId = _data["gaMeasurementId"];
            this.gaApiSecret = _data["gaApiSecret"];
        }
    }

    static fromJS(data: any): Project {
        data = typeof data === 'object' ? data : {};
        let result = new Project();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId;
        data["projectName"] = this.projectName;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>undefined;
        data["subscriptionType"] = this.subscriptionType;
        data["gaMeasurementId"] = this.gaMeasurementId;
        data["gaApiSecret"] = this.gaApiSecret;
        return data;
    }
}

export interface IProject {
    projectId: string;
    projectName?: string | undefined;
    createdTime: Date;
    subscriptionType: SubscriptionType;
    gaMeasurementId?: string | undefined;
    gaApiSecret?: string | undefined;
}

export enum SubscriptionType {
    Free = "Free",
    Unlimited = "Unlimited",
}

export class ProjectUpdateParams implements IProjectUpdateParams {
    projectName?: PatchOfString | undefined;
    gaMeasurementId?: PatchOfString | undefined;
    gaApiSecret?: PatchOfString | undefined;
    maxTcpCount?: PatchOfInteger | undefined;

    constructor(data?: IProjectUpdateParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectName = _data["projectName"] ? PatchOfString.fromJS(_data["projectName"]) : <any>undefined;
            this.gaMeasurementId = _data["gaMeasurementId"] ? PatchOfString.fromJS(_data["gaMeasurementId"]) : <any>undefined;
            this.gaApiSecret = _data["gaApiSecret"] ? PatchOfString.fromJS(_data["gaApiSecret"]) : <any>undefined;
            this.maxTcpCount = _data["maxTcpCount"] ? PatchOfInteger.fromJS(_data["maxTcpCount"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProjectUpdateParams {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectUpdateParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectName"] = this.projectName ? this.projectName.toJSON() : <any>undefined;
        data["gaMeasurementId"] = this.gaMeasurementId ? this.gaMeasurementId.toJSON() : <any>undefined;
        data["gaApiSecret"] = this.gaApiSecret ? this.gaApiSecret.toJSON() : <any>undefined;
        data["maxTcpCount"] = this.maxTcpCount ? this.maxTcpCount.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProjectUpdateParams {
    projectName?: PatchOfString | undefined;
    gaMeasurementId?: PatchOfString | undefined;
    gaApiSecret?: PatchOfString | undefined;
    maxTcpCount?: PatchOfInteger | undefined;
}

export class ServerFarm implements IServerFarm {
    serverFarmId!: string;
    serverFarmName!: string;
    serverProfileId!: string;
    serverProfileName!: string;
    useHostName!: boolean;
    certificateId!: string;
    secret!: string;
    createdTime!: Date;

    constructor(data?: IServerFarm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serverFarmId = _data["serverFarmId"];
            this.serverFarmName = _data["serverFarmName"];
            this.serverProfileId = _data["serverProfileId"];
            this.serverProfileName = _data["serverProfileName"];
            this.useHostName = _data["useHostName"];
            this.certificateId = _data["certificateId"];
            this.secret = _data["secret"];
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ServerFarm {
        data = typeof data === 'object' ? data : {};
        let result = new ServerFarm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverFarmId"] = this.serverFarmId;
        data["serverFarmName"] = this.serverFarmName;
        data["serverProfileId"] = this.serverProfileId;
        data["serverProfileName"] = this.serverProfileName;
        data["useHostName"] = this.useHostName;
        data["certificateId"] = this.certificateId;
        data["secret"] = this.secret;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IServerFarm {
    serverFarmId: string;
    serverFarmName: string;
    serverProfileId: string;
    serverProfileName: string;
    useHostName: boolean;
    certificateId: string;
    secret: string;
    createdTime: Date;
}

export class ServerFarmCreateParams implements IServerFarmCreateParams {
    serverFarmName?: string | undefined;
    serverProfileId?: string | undefined;
    certificateId?: string | undefined;
    useHostName!: boolean;

    constructor(data?: IServerFarmCreateParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serverFarmName = _data["serverFarmName"];
            this.serverProfileId = _data["serverProfileId"];
            this.certificateId = _data["certificateId"];
            this.useHostName = _data["useHostName"];
        }
    }

    static fromJS(data: any): ServerFarmCreateParams {
        data = typeof data === 'object' ? data : {};
        let result = new ServerFarmCreateParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverFarmName"] = this.serverFarmName;
        data["serverProfileId"] = this.serverProfileId;
        data["certificateId"] = this.certificateId;
        data["useHostName"] = this.useHostName;
        return data;
    }
}

export interface IServerFarmCreateParams {
    serverFarmName?: string | undefined;
    serverProfileId?: string | undefined;
    certificateId?: string | undefined;
    useHostName: boolean;
}

export class ServerFarmData implements IServerFarmData {
    serverFarm!: ServerFarm;
    certificate!: Certificate;
    accessPoints!: ServerFarmAccessPoint[];
    summary?: ServerFarmSummary | undefined;

    constructor(data?: IServerFarmData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.serverFarm = new ServerFarm();
            this.certificate = new Certificate();
            this.accessPoints = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serverFarm = _data["serverFarm"] ? ServerFarm.fromJS(_data["serverFarm"]) : new ServerFarm();
            this.certificate = _data["certificate"] ? Certificate.fromJS(_data["certificate"]) : new Certificate();
            if (Array.isArray(_data["accessPoints"])) {
                this.accessPoints = [] as any;
                for (let item of _data["accessPoints"])
                    this.accessPoints!.push(ServerFarmAccessPoint.fromJS(item));
            }
            this.summary = _data["summary"] ? ServerFarmSummary.fromJS(_data["summary"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ServerFarmData {
        data = typeof data === 'object' ? data : {};
        let result = new ServerFarmData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverFarm"] = this.serverFarm ? this.serverFarm.toJSON() : <any>undefined;
        data["certificate"] = this.certificate ? this.certificate.toJSON() : <any>undefined;
        if (Array.isArray(this.accessPoints)) {
            data["accessPoints"] = [];
            for (let item of this.accessPoints)
                data["accessPoints"].push(item.toJSON());
        }
        data["summary"] = this.summary ? this.summary.toJSON() : <any>undefined;
        return data;
    }
}

export interface IServerFarmData {
    serverFarm: ServerFarm;
    certificate: Certificate;
    accessPoints: ServerFarmAccessPoint[];
    summary?: ServerFarmSummary | undefined;
}

export class ServerFarmAccessPoint implements IServerFarmAccessPoint {
    serverFarmId!: string;
    serverId!: string;
    serverName!: string;
    tcpEndPoint!: string;

    constructor(data?: IServerFarmAccessPoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serverFarmId = _data["serverFarmId"];
            this.serverId = _data["serverId"];
            this.serverName = _data["serverName"];
            this.tcpEndPoint = _data["tcpEndPoint"];
        }
    }

    static fromJS(data: any): ServerFarmAccessPoint {
        data = typeof data === 'object' ? data : {};
        let result = new ServerFarmAccessPoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverFarmId"] = this.serverFarmId;
        data["serverId"] = this.serverId;
        data["serverName"] = this.serverName;
        data["tcpEndPoint"] = this.tcpEndPoint;
        return data;
    }
}

export interface IServerFarmAccessPoint {
    serverFarmId: string;
    serverId: string;
    serverName: string;
    tcpEndPoint: string;
}

export class ServerFarmSummary implements IServerFarmSummary {
    totalTokenCount!: number;
    activeTokenCount!: number;
    inactiveTokenCount!: number;
    unusedTokenCount!: number;
    serverCount!: number;

    constructor(data?: IServerFarmSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalTokenCount = _data["totalTokenCount"];
            this.activeTokenCount = _data["activeTokenCount"];
            this.inactiveTokenCount = _data["inactiveTokenCount"];
            this.unusedTokenCount = _data["unusedTokenCount"];
            this.serverCount = _data["serverCount"];
        }
    }

    static fromJS(data: any): ServerFarmSummary {
        data = typeof data === 'object' ? data : {};
        let result = new ServerFarmSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalTokenCount"] = this.totalTokenCount;
        data["activeTokenCount"] = this.activeTokenCount;
        data["inactiveTokenCount"] = this.inactiveTokenCount;
        data["unusedTokenCount"] = this.unusedTokenCount;
        data["serverCount"] = this.serverCount;
        return data;
    }
}

export interface IServerFarmSummary {
    totalTokenCount: number;
    activeTokenCount: number;
    inactiveTokenCount: number;
    unusedTokenCount: number;
    serverCount: number;
}

export class ServerFarmUpdateParams implements IServerFarmUpdateParams {
    serverFarmName?: PatchOfString | undefined;
    certificateId?: PatchOfGuid | undefined;
    serverProfileId?: PatchOfGuid | undefined;
    useHostName?: PatchOfBoolean | undefined;

    constructor(data?: IServerFarmUpdateParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serverFarmName = _data["serverFarmName"] ? PatchOfString.fromJS(_data["serverFarmName"]) : <any>undefined;
            this.certificateId = _data["certificateId"] ? PatchOfGuid.fromJS(_data["certificateId"]) : <any>undefined;
            this.serverProfileId = _data["serverProfileId"] ? PatchOfGuid.fromJS(_data["serverProfileId"]) : <any>undefined;
            this.useHostName = _data["useHostName"] ? PatchOfBoolean.fromJS(_data["useHostName"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ServerFarmUpdateParams {
        data = typeof data === 'object' ? data : {};
        let result = new ServerFarmUpdateParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverFarmName"] = this.serverFarmName ? this.serverFarmName.toJSON() : <any>undefined;
        data["certificateId"] = this.certificateId ? this.certificateId.toJSON() : <any>undefined;
        data["serverProfileId"] = this.serverProfileId ? this.serverProfileId.toJSON() : <any>undefined;
        data["useHostName"] = this.useHostName ? this.useHostName.toJSON() : <any>undefined;
        return data;
    }
}

export interface IServerFarmUpdateParams {
    serverFarmName?: PatchOfString | undefined;
    certificateId?: PatchOfGuid | undefined;
    serverProfileId?: PatchOfGuid | undefined;
    useHostName?: PatchOfBoolean | undefined;
}

export class ServerProfile implements IServerProfile {
    serverProfileId!: string;
    serverProfileName!: string;
    isDefault!: boolean;
    createdTime!: Date;
    serverConfig?: string | undefined;

    constructor(data?: IServerProfile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serverProfileId = _data["serverProfileId"];
            this.serverProfileName = _data["serverProfileName"];
            this.isDefault = _data["isDefault"];
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>undefined;
            this.serverConfig = _data["serverConfig"];
        }
    }

    static fromJS(data: any): ServerProfile {
        data = typeof data === 'object' ? data : {};
        let result = new ServerProfile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverProfileId"] = this.serverProfileId;
        data["serverProfileName"] = this.serverProfileName;
        data["isDefault"] = this.isDefault;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>undefined;
        data["serverConfig"] = this.serverConfig;
        return data;
    }
}

export interface IServerProfile {
    serverProfileId: string;
    serverProfileName: string;
    isDefault: boolean;
    createdTime: Date;
    serverConfig?: string | undefined;
}

export class ServerProfileCreateParams implements IServerProfileCreateParams {
    serverProfileName?: string | undefined;
    serverConfig?: string | undefined;

    constructor(data?: IServerProfileCreateParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serverProfileName = _data["serverProfileName"];
            this.serverConfig = _data["serverConfig"];
        }
    }

    static fromJS(data: any): ServerProfileCreateParams {
        data = typeof data === 'object' ? data : {};
        let result = new ServerProfileCreateParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverProfileName"] = this.serverProfileName;
        data["serverConfig"] = this.serverConfig;
        return data;
    }
}

export interface IServerProfileCreateParams {
    serverProfileName?: string | undefined;
    serverConfig?: string | undefined;
}

export class ServerProfileData implements IServerProfileData {
    serverProfile!: ServerProfile;
    summary?: ServerProfileSummary | undefined;

    constructor(data?: IServerProfileData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.serverProfile = new ServerProfile();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serverProfile = _data["serverProfile"] ? ServerProfile.fromJS(_data["serverProfile"]) : new ServerProfile();
            this.summary = _data["summary"] ? ServerProfileSummary.fromJS(_data["summary"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ServerProfileData {
        data = typeof data === 'object' ? data : {};
        let result = new ServerProfileData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverProfile"] = this.serverProfile ? this.serverProfile.toJSON() : <any>undefined;
        data["summary"] = this.summary ? this.summary.toJSON() : <any>undefined;
        return data;
    }
}

export interface IServerProfileData {
    serverProfile: ServerProfile;
    summary?: ServerProfileSummary | undefined;
}

export class ServerProfileSummary implements IServerProfileSummary {
    serverCount!: number;
    serverFarmCount!: number;

    constructor(data?: IServerProfileSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serverCount = _data["serverCount"];
            this.serverFarmCount = _data["serverFarmCount"];
        }
    }

    static fromJS(data: any): ServerProfileSummary {
        data = typeof data === 'object' ? data : {};
        let result = new ServerProfileSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverCount"] = this.serverCount;
        data["serverFarmCount"] = this.serverFarmCount;
        return data;
    }
}

export interface IServerProfileSummary {
    serverCount: number;
    serverFarmCount: number;
}

export class ServerProfileUpdateParams implements IServerProfileUpdateParams {
    serverProfileName?: PatchOfString | undefined;
    serverConfig?: PatchOfString | undefined;

    constructor(data?: IServerProfileUpdateParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serverProfileName = _data["serverProfileName"] ? PatchOfString.fromJS(_data["serverProfileName"]) : <any>undefined;
            this.serverConfig = _data["serverConfig"] ? PatchOfString.fromJS(_data["serverConfig"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ServerProfileUpdateParams {
        data = typeof data === 'object' ? data : {};
        let result = new ServerProfileUpdateParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverProfileName"] = this.serverProfileName ? this.serverProfileName.toJSON() : <any>undefined;
        data["serverConfig"] = this.serverConfig ? this.serverConfig.toJSON() : <any>undefined;
        return data;
    }
}

export interface IServerProfileUpdateParams {
    serverProfileName?: PatchOfString | undefined;
    serverConfig?: PatchOfString | undefined;
}

export class VpnServer implements IVpnServer {
    serverId!: string;
    serverName!: string;
    serverFarmId!: string;
    serverFarmName?: string | undefined;
    version?: string | undefined;
    environmentVersion?: string | undefined;
    osInfo?: string | undefined;
    machineName?: string | undefined;
    totalMemory?: number | undefined;
    logicalCoreCount?: number | undefined;
    configureTime?: Date | undefined;
    createdTime!: Date;
    autoConfigure!: boolean;
    isEnabled!: boolean;
    description?: string | undefined;
    lastConfigError?: string | undefined;
    serverState!: ServerState;
    serverStatus?: ServerStatusEx | undefined;
    accessPoints!: AccessPoint[];

    constructor(data?: IVpnServer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.accessPoints = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serverId = _data["serverId"];
            this.serverName = _data["serverName"];
            this.serverFarmId = _data["serverFarmId"];
            this.serverFarmName = _data["serverFarmName"];
            this.version = _data["version"];
            this.environmentVersion = _data["environmentVersion"];
            this.osInfo = _data["osInfo"];
            this.machineName = _data["machineName"];
            this.totalMemory = _data["totalMemory"];
            this.logicalCoreCount = _data["logicalCoreCount"];
            this.configureTime = _data["configureTime"] ? new Date(_data["configureTime"].toString()) : <any>undefined;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>undefined;
            this.autoConfigure = _data["autoConfigure"];
            this.isEnabled = _data["isEnabled"];
            this.description = _data["description"];
            this.lastConfigError = _data["lastConfigError"];
            this.serverState = _data["serverState"];
            this.serverStatus = _data["serverStatus"] ? ServerStatusEx.fromJS(_data["serverStatus"]) : <any>undefined;
            if (Array.isArray(_data["accessPoints"])) {
                this.accessPoints = [] as any;
                for (let item of _data["accessPoints"])
                    this.accessPoints!.push(AccessPoint.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VpnServer {
        data = typeof data === 'object' ? data : {};
        let result = new VpnServer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverId"] = this.serverId;
        data["serverName"] = this.serverName;
        data["serverFarmId"] = this.serverFarmId;
        data["serverFarmName"] = this.serverFarmName;
        data["version"] = this.version;
        data["environmentVersion"] = this.environmentVersion;
        data["osInfo"] = this.osInfo;
        data["machineName"] = this.machineName;
        data["totalMemory"] = this.totalMemory;
        data["logicalCoreCount"] = this.logicalCoreCount;
        data["configureTime"] = this.configureTime ? this.configureTime.toISOString() : <any>undefined;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>undefined;
        data["autoConfigure"] = this.autoConfigure;
        data["isEnabled"] = this.isEnabled;
        data["description"] = this.description;
        data["lastConfigError"] = this.lastConfigError;
        data["serverState"] = this.serverState;
        data["serverStatus"] = this.serverStatus ? this.serverStatus.toJSON() : <any>undefined;
        if (Array.isArray(this.accessPoints)) {
            data["accessPoints"] = [];
            for (let item of this.accessPoints)
                data["accessPoints"].push(item.toJSON());
        }
        return data;
    }
}

export interface IVpnServer {
    serverId: string;
    serverName: string;
    serverFarmId: string;
    serverFarmName?: string | undefined;
    version?: string | undefined;
    environmentVersion?: string | undefined;
    osInfo?: string | undefined;
    machineName?: string | undefined;
    totalMemory?: number | undefined;
    logicalCoreCount?: number | undefined;
    configureTime?: Date | undefined;
    createdTime: Date;
    autoConfigure: boolean;
    isEnabled: boolean;
    description?: string | undefined;
    lastConfigError?: string | undefined;
    serverState: ServerState;
    serverStatus?: ServerStatusEx | undefined;
    accessPoints: AccessPoint[];
}

export enum ServerState {
    NotInstalled = "NotInstalled",
    Disabled = "Disabled",
    Lost = "Lost",
    Configuring = "Configuring",
    Idle = "Idle",
    Active = "Active",
}

export class ServerStatusEx implements IServerStatusEx {
    sessionCount!: number;
    tcpConnectionCount!: number;
    udpConnectionCount!: number;
    availableMemory?: number | undefined;
    cpuUsage?: number | undefined;
    threadCount!: number;
    tunnelSendSpeed!: number;
    tunnelReceiveSpeed!: number;
    createdTime!: Date;

    constructor(data?: IServerStatusEx) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sessionCount = _data["sessionCount"];
            this.tcpConnectionCount = _data["tcpConnectionCount"];
            this.udpConnectionCount = _data["udpConnectionCount"];
            this.availableMemory = _data["availableMemory"];
            this.cpuUsage = _data["cpuUsage"];
            this.threadCount = _data["threadCount"];
            this.tunnelSendSpeed = _data["tunnelSendSpeed"];
            this.tunnelReceiveSpeed = _data["tunnelReceiveSpeed"];
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ServerStatusEx {
        data = typeof data === 'object' ? data : {};
        let result = new ServerStatusEx();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sessionCount"] = this.sessionCount;
        data["tcpConnectionCount"] = this.tcpConnectionCount;
        data["udpConnectionCount"] = this.udpConnectionCount;
        data["availableMemory"] = this.availableMemory;
        data["cpuUsage"] = this.cpuUsage;
        data["threadCount"] = this.threadCount;
        data["tunnelSendSpeed"] = this.tunnelSendSpeed;
        data["tunnelReceiveSpeed"] = this.tunnelReceiveSpeed;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IServerStatusEx {
    sessionCount: number;
    tcpConnectionCount: number;
    udpConnectionCount: number;
    availableMemory?: number | undefined;
    cpuUsage?: number | undefined;
    threadCount: number;
    tunnelSendSpeed: number;
    tunnelReceiveSpeed: number;
    createdTime: Date;
}

export class AccessPoint implements IAccessPoint {
    ipAddress!: string;
    accessPointMode!: AccessPointMode;
    isListen!: boolean;
    tcpPort!: number;
    udpPort!: number;

    constructor(data?: IAccessPoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ipAddress = _data["ipAddress"];
            this.accessPointMode = _data["accessPointMode"];
            this.isListen = _data["isListen"];
            this.tcpPort = _data["tcpPort"];
            this.udpPort = _data["udpPort"];
        }
    }

    static fromJS(data: any): AccessPoint {
        data = typeof data === 'object' ? data : {};
        let result = new AccessPoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ipAddress"] = this.ipAddress;
        data["accessPointMode"] = this.accessPointMode;
        data["isListen"] = this.isListen;
        data["tcpPort"] = this.tcpPort;
        data["udpPort"] = this.udpPort;
        return data;
    }
}

export interface IAccessPoint {
    ipAddress: string;
    accessPointMode: AccessPointMode;
    isListen: boolean;
    tcpPort: number;
    udpPort: number;
}

export enum AccessPointMode {
    Private = "Private",
    Public = "Public",
    PublicInToken = "PublicInToken",
}

export class ServerCreateParams implements IServerCreateParams {
    serverName?: string | undefined;
    serverFarmId!: string;
    accessPoints?: AccessPoint[] | undefined;

    constructor(data?: IServerCreateParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serverName = _data["serverName"];
            this.serverFarmId = _data["serverFarmId"];
            if (Array.isArray(_data["accessPoints"])) {
                this.accessPoints = [] as any;
                for (let item of _data["accessPoints"])
                    this.accessPoints!.push(AccessPoint.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ServerCreateParams {
        data = typeof data === 'object' ? data : {};
        let result = new ServerCreateParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverName"] = this.serverName;
        data["serverFarmId"] = this.serverFarmId;
        if (Array.isArray(this.accessPoints)) {
            data["accessPoints"] = [];
            for (let item of this.accessPoints)
                data["accessPoints"].push(item.toJSON());
        }
        return data;
    }
}

export interface IServerCreateParams {
    serverName?: string | undefined;
    serverFarmId: string;
    accessPoints?: AccessPoint[] | undefined;
}

export class ServerUpdateParams implements IServerUpdateParams {
    serverName?: PatchOfString | undefined;
    serverFarmId?: PatchOfGuid | undefined;
    generateNewSecret?: PatchOfBoolean | undefined;
    autoConfigure?: PatchOfBoolean | undefined;
    accessPoints?: PatchOfAccessPointOf | undefined;

    constructor(data?: IServerUpdateParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serverName = _data["serverName"] ? PatchOfString.fromJS(_data["serverName"]) : <any>undefined;
            this.serverFarmId = _data["serverFarmId"] ? PatchOfGuid.fromJS(_data["serverFarmId"]) : <any>undefined;
            this.generateNewSecret = _data["generateNewSecret"] ? PatchOfBoolean.fromJS(_data["generateNewSecret"]) : <any>undefined;
            this.autoConfigure = _data["autoConfigure"] ? PatchOfBoolean.fromJS(_data["autoConfigure"]) : <any>undefined;
            this.accessPoints = _data["accessPoints"] ? PatchOfAccessPointOf.fromJS(_data["accessPoints"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ServerUpdateParams {
        data = typeof data === 'object' ? data : {};
        let result = new ServerUpdateParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverName"] = this.serverName ? this.serverName.toJSON() : <any>undefined;
        data["serverFarmId"] = this.serverFarmId ? this.serverFarmId.toJSON() : <any>undefined;
        data["generateNewSecret"] = this.generateNewSecret ? this.generateNewSecret.toJSON() : <any>undefined;
        data["autoConfigure"] = this.autoConfigure ? this.autoConfigure.toJSON() : <any>undefined;
        data["accessPoints"] = this.accessPoints ? this.accessPoints.toJSON() : <any>undefined;
        return data;
    }
}

export interface IServerUpdateParams {
    serverName?: PatchOfString | undefined;
    serverFarmId?: PatchOfGuid | undefined;
    generateNewSecret?: PatchOfBoolean | undefined;
    autoConfigure?: PatchOfBoolean | undefined;
    accessPoints?: PatchOfAccessPointOf | undefined;
}

export class PatchOfAccessPointOf implements IPatchOfAccessPointOf {
    value!: AccessPoint[];

    constructor(data?: IPatchOfAccessPointOf) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.value = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(AccessPoint.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PatchOfAccessPointOf {
        data = typeof data === 'object' ? data : {};
        let result = new PatchOfAccessPointOf();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPatchOfAccessPointOf {
    value: AccessPoint[];
}

export class ServerData implements IServerData {
    server!: VpnServer;

    constructor(data?: IServerData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.server = new VpnServer();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.server = _data["server"] ? VpnServer.fromJS(_data["server"]) : new VpnServer();
        }
    }

    static fromJS(data: any): ServerData {
        data = typeof data === 'object' ? data : {};
        let result = new ServerData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["server"] = this.server ? this.server.toJSON() : <any>undefined;
        return data;
    }
}

export interface IServerData {
    server: VpnServer;
}

export class ServerInstallBySshUserPasswordParams implements IServerInstallBySshUserPasswordParams {
    hostName!: string;
    hostPort!: number;
    userName!: string;
    password!: string;

    constructor(data?: IServerInstallBySshUserPasswordParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hostName = _data["hostName"];
            this.hostPort = _data["hostPort"];
            this.userName = _data["userName"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): ServerInstallBySshUserPasswordParams {
        data = typeof data === 'object' ? data : {};
        let result = new ServerInstallBySshUserPasswordParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hostName"] = this.hostName;
        data["hostPort"] = this.hostPort;
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data;
    }
}

export interface IServerInstallBySshUserPasswordParams {
    hostName: string;
    hostPort: number;
    userName: string;
    password: string;
}

export class ServerInstallBySshUserKeyParams implements IServerInstallBySshUserKeyParams {
    hostName!: string;
    hostPort!: number;
    userName!: string;
    userKey!: string;
    userKeyPassphrase?: string | undefined;

    constructor(data?: IServerInstallBySshUserKeyParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hostName = _data["hostName"];
            this.hostPort = _data["hostPort"];
            this.userName = _data["userName"];
            this.userKey = _data["userKey"];
            this.userKeyPassphrase = _data["userKeyPassphrase"];
        }
    }

    static fromJS(data: any): ServerInstallBySshUserKeyParams {
        data = typeof data === 'object' ? data : {};
        let result = new ServerInstallBySshUserKeyParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hostName"] = this.hostName;
        data["hostPort"] = this.hostPort;
        data["userName"] = this.userName;
        data["userKey"] = this.userKey;
        data["userKeyPassphrase"] = this.userKeyPassphrase;
        return data;
    }
}

export interface IServerInstallBySshUserKeyParams {
    hostName: string;
    hostPort: number;
    userName: string;
    userKey: string;
    userKeyPassphrase?: string | undefined;
}

export class ServerInstallManual implements IServerInstallManual {
    appSettingsJson!: string;
    appSettings!: ServerInstallAppSettings;
    linuxCommand!: string;
    windowsCommand!: string;

    constructor(data?: IServerInstallManual) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.appSettings = new ServerInstallAppSettings();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appSettingsJson = _data["appSettingsJson"];
            this.appSettings = _data["appSettings"] ? ServerInstallAppSettings.fromJS(_data["appSettings"]) : new ServerInstallAppSettings();
            this.linuxCommand = _data["linuxCommand"];
            this.windowsCommand = _data["windowsCommand"];
        }
    }

    static fromJS(data: any): ServerInstallManual {
        data = typeof data === 'object' ? data : {};
        let result = new ServerInstallManual();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appSettingsJson"] = this.appSettingsJson;
        data["appSettings"] = this.appSettings ? this.appSettings.toJSON() : <any>undefined;
        data["linuxCommand"] = this.linuxCommand;
        data["windowsCommand"] = this.windowsCommand;
        return data;
    }
}

export interface IServerInstallManual {
    appSettingsJson: string;
    appSettings: ServerInstallAppSettings;
    linuxCommand: string;
    windowsCommand: string;
}

export class ServerInstallAppSettings implements IServerInstallAppSettings {
    httpAccessManager!: HttpAccessManagerOptions;
    managementSecret!: string;

    constructor(data?: IServerInstallAppSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.httpAccessManager = new HttpAccessManagerOptions();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.httpAccessManager = _data["httpAccessManager"] ? HttpAccessManagerOptions.fromJS(_data["httpAccessManager"]) : new HttpAccessManagerOptions();
            this.managementSecret = _data["managementSecret"];
        }
    }

    static fromJS(data: any): ServerInstallAppSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ServerInstallAppSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["httpAccessManager"] = this.httpAccessManager ? this.httpAccessManager.toJSON() : <any>undefined;
        data["managementSecret"] = this.managementSecret;
        return data;
    }
}

export interface IServerInstallAppSettings {
    httpAccessManager: HttpAccessManagerOptions;
    managementSecret: string;
}

export class HttpAccessManagerOptions implements IHttpAccessManagerOptions {
    baseUrl!: string;
    authorization!: string;

    constructor(data?: IHttpAccessManagerOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.baseUrl = _data["baseUrl"];
            this.authorization = _data["authorization"];
        }
    }

    static fromJS(data: any): HttpAccessManagerOptions {
        data = typeof data === 'object' ? data : {};
        let result = new HttpAccessManagerOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseUrl"] = this.baseUrl;
        data["authorization"] = this.authorization;
        return data;
    }
}

export interface IHttpAccessManagerOptions {
    baseUrl: string;
    authorization: string;
}

export class ServersStatusSummary implements IServersStatusSummary {
    totalServerCount!: number;
    activeServerCount!: number;
    idleServerCount!: number;
    lostServerCount!: number;
    notInstalledServerCount!: number;
    sessionCount!: number;
    tunnelSendSpeed!: number;
    tunnelReceiveSpeed!: number;
    usingBandwidth!: number;

    constructor(data?: IServersStatusSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalServerCount = _data["totalServerCount"];
            this.activeServerCount = _data["activeServerCount"];
            this.idleServerCount = _data["idleServerCount"];
            this.lostServerCount = _data["lostServerCount"];
            this.notInstalledServerCount = _data["notInstalledServerCount"];
            this.sessionCount = _data["sessionCount"];
            this.tunnelSendSpeed = _data["tunnelSendSpeed"];
            this.tunnelReceiveSpeed = _data["tunnelReceiveSpeed"];
            this.usingBandwidth = _data["usingBandwidth"];
        }
    }

    static fromJS(data: any): ServersStatusSummary {
        data = typeof data === 'object' ? data : {};
        let result = new ServersStatusSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalServerCount"] = this.totalServerCount;
        data["activeServerCount"] = this.activeServerCount;
        data["idleServerCount"] = this.idleServerCount;
        data["lostServerCount"] = this.lostServerCount;
        data["notInstalledServerCount"] = this.notInstalledServerCount;
        data["sessionCount"] = this.sessionCount;
        data["tunnelSendSpeed"] = this.tunnelSendSpeed;
        data["tunnelReceiveSpeed"] = this.tunnelReceiveSpeed;
        data["usingBandwidth"] = this.usingBandwidth;
        return data;
    }
}

export interface IServersStatusSummary {
    totalServerCount: number;
    activeServerCount: number;
    idleServerCount: number;
    lostServerCount: number;
    notInstalledServerCount: number;
    sessionCount: number;
    tunnelSendSpeed: number;
    tunnelReceiveSpeed: number;
    usingBandwidth: number;
}

export class ServerStatusHistory implements IServerStatusHistory {
    time!: Date;
    sessionCount!: number;
    tunnelTransferSpeed!: number;
    serverCount!: number;

    constructor(data?: IServerStatusHistory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.time = _data["time"] ? new Date(_data["time"].toString()) : <any>undefined;
            this.sessionCount = _data["sessionCount"];
            this.tunnelTransferSpeed = _data["tunnelTransferSpeed"];
            this.serverCount = _data["serverCount"];
        }
    }

    static fromJS(data: any): ServerStatusHistory {
        data = typeof data === 'object' ? data : {};
        let result = new ServerStatusHistory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["time"] = this.time ? this.time.toISOString() : <any>undefined;
        data["sessionCount"] = this.sessionCount;
        data["tunnelTransferSpeed"] = this.tunnelTransferSpeed;
        data["serverCount"] = this.serverCount;
        return data;
    }
}

export interface IServerStatusHistory {
    time: Date;
    sessionCount: number;
    tunnelTransferSpeed: number;
    serverCount: number;
}

export class ApiKey implements IApiKey {
    accessToken!: Token;
    refreshToken?: Token | undefined;
    userId!: string;

    constructor(data?: IApiKey) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.accessToken = new Token();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"] ? Token.fromJS(_data["accessToken"]) : new Token();
            this.refreshToken = _data["refreshToken"] ? Token.fromJS(_data["refreshToken"]) : <any>undefined;
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): ApiKey {
        data = typeof data === 'object' ? data : {};
        let result = new ApiKey();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken ? this.accessToken.toJSON() : <any>undefined;
        data["refreshToken"] = this.refreshToken ? this.refreshToken.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IApiKey {
    accessToken: Token;
    refreshToken?: Token | undefined;
    userId: string;
}

export class Token implements IToken {
    value!: string;
    expirationTime!: Date;
    scheme!: string;
    issuedTime!: Date;

    constructor(data?: IToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.expirationTime = _data["expirationTime"] ? new Date(_data["expirationTime"].toString()) : <any>undefined;
            this.scheme = _data["scheme"];
            this.issuedTime = _data["issuedTime"] ? new Date(_data["issuedTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Token {
        data = typeof data === 'object' ? data : {};
        let result = new Token();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["expirationTime"] = this.expirationTime ? this.expirationTime.toISOString() : <any>undefined;
        data["scheme"] = this.scheme;
        data["issuedTime"] = this.issuedTime ? this.issuedTime.toISOString() : <any>undefined;
        return data;
    }
}

export interface IToken {
    value: string;
    expirationTime: Date;
    scheme: string;
    issuedTime: Date;
}

export class User implements IUser {
    userId!: string;
    email!: string;
    name?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    pictureUrl?: string | undefined;
    phone?: string | undefined;
    createdTime!: Date;
    accessedTime?: Date | undefined;
    authorizationCode?: string | undefined;
    isDisabled!: boolean;
    isEmailVerified!: boolean;
    isPhoneVerified!: boolean;
    isBot!: boolean;
    description?: string | undefined;
    exData?: string | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.email = _data["email"];
            this.name = _data["name"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.pictureUrl = _data["pictureUrl"];
            this.phone = _data["phone"];
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>undefined;
            this.accessedTime = _data["accessedTime"] ? new Date(_data["accessedTime"].toString()) : <any>undefined;
            this.authorizationCode = _data["authorizationCode"];
            this.isDisabled = _data["isDisabled"];
            this.isEmailVerified = _data["isEmailVerified"];
            this.isPhoneVerified = _data["isPhoneVerified"];
            this.isBot = _data["isBot"];
            this.description = _data["description"];
            this.exData = _data["exData"];
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["email"] = this.email;
        data["name"] = this.name;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["pictureUrl"] = this.pictureUrl;
        data["phone"] = this.phone;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>undefined;
        data["accessedTime"] = this.accessedTime ? this.accessedTime.toISOString() : <any>undefined;
        data["authorizationCode"] = this.authorizationCode;
        data["isDisabled"] = this.isDisabled;
        data["isEmailVerified"] = this.isEmailVerified;
        data["isPhoneVerified"] = this.isPhoneVerified;
        data["isBot"] = this.isBot;
        data["description"] = this.description;
        data["exData"] = this.exData;
        return data;
    }
}

export interface IUser {
    userId: string;
    email: string;
    name?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    pictureUrl?: string | undefined;
    phone?: string | undefined;
    createdTime: Date;
    accessedTime?: Date | undefined;
    authorizationCode?: string | undefined;
    isDisabled: boolean;
    isEmailVerified: boolean;
    isPhoneVerified: boolean;
    isBot: boolean;
    description?: string | undefined;
    exData?: string | undefined;
}

export class TeamUpdateBotParam implements ITeamUpdateBotParam {
    name?: PatchOfString2 | undefined;

    constructor(data?: ITeamUpdateBotParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] ? PatchOfString2.fromJS(_data["name"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TeamUpdateBotParam {
        data = typeof data === 'object' ? data : {};
        let result = new TeamUpdateBotParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name ? this.name.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITeamUpdateBotParam {
    name?: PatchOfString2 | undefined;
}

export class PatchOfString2 implements IPatchOfString2 {
    value!: string;

    constructor(data?: IPatchOfString2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): PatchOfString2 {
        data = typeof data === 'object' ? data : {};
        let result = new PatchOfString2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        return data;
    }
}

export interface IPatchOfString2 {
    value: string;
}

export class Role implements IRole {
    roleId!: string;
    roleName!: string;
    description?: string | undefined;

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): Role {
        data = typeof data === 'object' ? data : {};
        let result = new Role();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["description"] = this.description;
        return data;
    }
}

export interface IRole {
    roleId: string;
    roleName: string;
    description?: string | undefined;
}

export class ListResultOfUserRole implements IListResultOfUserRole {
    totalCount?: number | undefined;
    items!: UserRole[];

    constructor(data?: IListResultOfUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserRole.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultOfUserRole {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultOfUserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultOfUserRole {
    totalCount?: number | undefined;
    items: UserRole[];
}

export class UserRole2 implements IUserRole2 {
    resourceId!: string;
    userId!: string;
    role!: Role;

    constructor(data?: IUserRole2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.role = new Role();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.resourceId = _data["resourceId"];
            this.userId = _data["userId"];
            this.role = _data["role"] ? Role.fromJS(_data["role"]) : new Role();
        }
    }

    static fromJS(data: any): UserRole2 {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resourceId"] = this.resourceId;
        data["userId"] = this.userId;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUserRole2 {
    resourceId: string;
    userId: string;
    role: Role;
}

export class UserRole extends UserRole2 implements IUserRole {
    user?: User | undefined;

    constructor(data?: IUserRole) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserRole {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IUserRole extends IUserRole2 {
    user?: User | undefined;
}

export class TeamAddBotParam implements ITeamAddBotParam {
    name!: string;

    constructor(data?: ITeamAddBotParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): TeamAddBotParam {
        data = typeof data === 'object' ? data : {};
        let result = new TeamAddBotParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ITeamAddBotParam {
    name: string;
}

export class TeamAddEmailParam implements ITeamAddEmailParam {

    constructor(data?: ITeamAddEmailParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): TeamAddEmailParam {
        data = typeof data === 'object' ? data : {};
        let result = new TeamAddEmailParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface ITeamAddEmailParam {
}

export class SignInRequest implements ISignInRequest {
    idToken!: string;
    refreshTokenType!: RefreshTokenType;

    constructor(data?: ISignInRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idToken = _data["idToken"];
            this.refreshTokenType = _data["refreshTokenType"];
        }
    }

    static fromJS(data: any): SignInRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SignInRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idToken"] = this.idToken;
        data["refreshTokenType"] = this.refreshTokenType;
        return data;
    }
}

export interface ISignInRequest {
    idToken: string;
    refreshTokenType: RefreshTokenType;
}

export enum RefreshTokenType {
    None = 0,
    Web = 1,
    App = 2,
}

export class SignUpRequest implements ISignUpRequest {
    idToken!: string;
    refreshTokenType!: RefreshTokenType;

    constructor(data?: ISignUpRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idToken = _data["idToken"];
            this.refreshTokenType = _data["refreshTokenType"];
        }
    }

    static fromJS(data: any): SignUpRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SignUpRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idToken"] = this.idToken;
        data["refreshTokenType"] = this.refreshTokenType;
        return data;
    }
}

export interface ISignUpRequest {
    idToken: string;
    refreshTokenType: RefreshTokenType;
}

export class RefreshTokenRequest implements IRefreshTokenRequest {
    refreshToken!: string;

    constructor(data?: IRefreshTokenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): RefreshTokenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IRefreshTokenRequest {
    refreshToken: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

}