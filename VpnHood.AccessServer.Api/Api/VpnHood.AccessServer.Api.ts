//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class AccessesClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    get(projectId: string, accessId: string, cancelToken?: CancelToken): Promise<AccessData> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/accesses/{accessId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (accessId === undefined || accessId === null)
            throw new Error("The parameter 'accessId' must be defined.");
        url_ = url_.replace("{accessId}", encodeURIComponent("" + accessId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<AccessData> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AccessData.fromJS(resultData200);
            return Promise.resolve<AccessData>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccessData>(null as any);
    }

    list(projectId: string, accessTokenId?: string | null | undefined, serverFarmId?: string | null | undefined, accessId?: string | null | undefined, beginTime?: Date | null | undefined, endTime?: Date | null | undefined, recordIndex?: number | undefined, recordCount?: number | undefined, cancelToken?: CancelToken): Promise<ListResultOfAccessData> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/accesses?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (accessTokenId !== undefined && accessTokenId !== null)
            url_ += "accessTokenId=" + encodeURIComponent("" + accessTokenId) + "&";
        if (serverFarmId !== undefined && serverFarmId !== null)
            url_ += "serverFarmId=" + encodeURIComponent("" + serverFarmId) + "&";
        if (accessId !== undefined && accessId !== null)
            url_ += "accessId=" + encodeURIComponent("" + accessId) + "&";
        if (beginTime !== undefined && beginTime !== null)
            url_ += "beginTime=" + encodeURIComponent(beginTime ? "" + beginTime.toISOString() : "") + "&";
        if (endTime !== undefined && endTime !== null)
            url_ += "endTime=" + encodeURIComponent(endTime ? "" + endTime.toISOString() : "") + "&";
        if (recordIndex === null)
            throw new Error("The parameter 'recordIndex' cannot be null.");
        else if (recordIndex !== undefined)
            url_ += "recordIndex=" + encodeURIComponent("" + recordIndex) + "&";
        if (recordCount === null)
            throw new Error("The parameter 'recordCount' cannot be null.");
        else if (recordCount !== undefined)
            url_ += "recordCount=" + encodeURIComponent("" + recordCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processList(_response);
        });
    }

    protected processList(response: AxiosResponse): Promise<ListResultOfAccessData> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListResultOfAccessData.fromJS(resultData200);
            return Promise.resolve<ListResultOfAccessData>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListResultOfAccessData>(null as any);
    }
}

export class AccessTokensClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    create(projectId: string, createParams: AccessTokenCreateParams, cancelToken?: CancelToken): Promise<AccessToken> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/access-tokens";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createParams);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<AccessToken> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AccessToken.fromJS(resultData200);
            return Promise.resolve<AccessToken>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccessToken>(null as any);
    }

    list(projectId: string, search?: string | null | undefined, accessTokenId?: string | null | undefined, serverFarmId?: string | null | undefined, usageBeginTime?: Date | null | undefined, usageEndTime?: Date | null | undefined, recordIndex?: number | undefined, recordCount?: number | undefined, cancelToken?: CancelToken): Promise<ListResultOfAccessTokenData> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/access-tokens?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (accessTokenId !== undefined && accessTokenId !== null)
            url_ += "accessTokenId=" + encodeURIComponent("" + accessTokenId) + "&";
        if (serverFarmId !== undefined && serverFarmId !== null)
            url_ += "serverFarmId=" + encodeURIComponent("" + serverFarmId) + "&";
        if (usageBeginTime !== undefined && usageBeginTime !== null)
            url_ += "usageBeginTime=" + encodeURIComponent(usageBeginTime ? "" + usageBeginTime.toISOString() : "") + "&";
        if (usageEndTime !== undefined && usageEndTime !== null)
            url_ += "usageEndTime=" + encodeURIComponent(usageEndTime ? "" + usageEndTime.toISOString() : "") + "&";
        if (recordIndex === null)
            throw new Error("The parameter 'recordIndex' cannot be null.");
        else if (recordIndex !== undefined)
            url_ += "recordIndex=" + encodeURIComponent("" + recordIndex) + "&";
        if (recordCount === null)
            throw new Error("The parameter 'recordCount' cannot be null.");
        else if (recordCount !== undefined)
            url_ += "recordCount=" + encodeURIComponent("" + recordCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processList(_response);
        });
    }

    protected processList(response: AxiosResponse): Promise<ListResultOfAccessTokenData> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListResultOfAccessTokenData.fromJS(resultData200);
            return Promise.resolve<ListResultOfAccessTokenData>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListResultOfAccessTokenData>(null as any);
    }

    deleteMany(projectId: string, accessTokenIds: string[], cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/access-tokens";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(accessTokenIds);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "DELETE",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteMany(_response);
        });
    }

    protected processDeleteMany(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    update(projectId: string, accessTokenId: string, updateParams: AccessTokenUpdateParams, cancelToken?: CancelToken): Promise<AccessToken> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/access-tokens/{accessTokenId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (accessTokenId === undefined || accessTokenId === null)
            throw new Error("The parameter 'accessTokenId' must be defined.");
        url_ = url_.replace("{accessTokenId}", encodeURIComponent("" + accessTokenId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateParams);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<AccessToken> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AccessToken.fromJS(resultData200);
            return Promise.resolve<AccessToken>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccessToken>(null as any);
    }

    get(projectId: string, accessTokenId: string, usageBeginTime?: Date | null | undefined, usageEndTime?: Date | null | undefined, cancelToken?: CancelToken): Promise<AccessTokenData> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/access-tokens/{accessTokenId}?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (accessTokenId === undefined || accessTokenId === null)
            throw new Error("The parameter 'accessTokenId' must be defined.");
        url_ = url_.replace("{accessTokenId}", encodeURIComponent("" + accessTokenId));
        if (usageBeginTime !== undefined && usageBeginTime !== null)
            url_ += "usageBeginTime=" + encodeURIComponent(usageBeginTime ? "" + usageBeginTime.toISOString() : "") + "&";
        if (usageEndTime !== undefined && usageEndTime !== null)
            url_ += "usageEndTime=" + encodeURIComponent(usageEndTime ? "" + usageEndTime.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<AccessTokenData> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AccessTokenData.fromJS(resultData200);
            return Promise.resolve<AccessTokenData>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AccessTokenData>(null as any);
    }

    delete(projectId: string, accessTokenId: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/access-tokens/{accessTokenId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (accessTokenId === undefined || accessTokenId === null)
            throw new Error("The parameter 'accessTokenId' must be defined.");
        url_ = url_.replace("{accessTokenId}", encodeURIComponent("" + accessTokenId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    getAccessKey(projectId: string, accessTokenId: string, cancelToken?: CancelToken): Promise<string> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/access-tokens/{accessTokenId}/access-key";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (accessTokenId === undefined || accessTokenId === null)
            throw new Error("The parameter 'accessTokenId' must be defined.");
        url_ = url_.replace("{accessTokenId}", encodeURIComponent("" + accessTokenId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAccessKey(_response);
        });
    }

    protected processGetAccessKey(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }
}

export class DevicesClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    get(projectId: string, deviceId: string, usageBeginTime?: Date | null | undefined, usageEndTime?: Date | null | undefined, cancelToken?: CancelToken): Promise<DeviceData> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/devices/{deviceId}?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        if (usageBeginTime !== undefined && usageBeginTime !== null)
            url_ += "usageBeginTime=" + encodeURIComponent(usageBeginTime ? "" + usageBeginTime.toISOString() : "") + "&";
        if (usageEndTime !== undefined && usageEndTime !== null)
            url_ += "usageEndTime=" + encodeURIComponent(usageEndTime ? "" + usageEndTime.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<DeviceData> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DeviceData.fromJS(resultData200);
            return Promise.resolve<DeviceData>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DeviceData>(null as any);
    }

    update(projectId: string, deviceId: string, updateParams: DeviceUpdateParams, cancelToken?: CancelToken): Promise<Device> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/devices/{deviceId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateParams);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<Device> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Device.fromJS(resultData200);
            return Promise.resolve<Device>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Device>(null as any);
    }

    findByClientId(projectId: string, clientId: string, cancelToken?: CancelToken): Promise<Device> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/devices/clientId:{clientId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (clientId === undefined || clientId === null)
            throw new Error("The parameter 'clientId' must be defined.");
        url_ = url_.replace("{clientId}", encodeURIComponent("" + clientId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFindByClientId(_response);
        });
    }

    protected processFindByClientId(response: AxiosResponse): Promise<Device> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Device.fromJS(resultData200);
            return Promise.resolve<Device>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Device>(null as any);
    }

    list(projectId: string, deviceId?: string | null | undefined, usageBeginTime?: Date | null | undefined, usageEndTime?: Date | null | undefined, recordIndex?: number | undefined, recordCount?: number | undefined, cancelToken?: CancelToken): Promise<DeviceData[]> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/devices?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (deviceId !== undefined && deviceId !== null)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (usageBeginTime !== undefined && usageBeginTime !== null)
            url_ += "usageBeginTime=" + encodeURIComponent(usageBeginTime ? "" + usageBeginTime.toISOString() : "") + "&";
        if (usageEndTime !== undefined && usageEndTime !== null)
            url_ += "usageEndTime=" + encodeURIComponent(usageEndTime ? "" + usageEndTime.toISOString() : "") + "&";
        if (recordIndex === null)
            throw new Error("The parameter 'recordIndex' cannot be null.");
        else if (recordIndex !== undefined)
            url_ += "recordIndex=" + encodeURIComponent("" + recordIndex) + "&";
        if (recordCount === null)
            throw new Error("The parameter 'recordCount' cannot be null.");
        else if (recordCount !== undefined)
            url_ += "recordCount=" + encodeURIComponent("" + recordCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processList(_response);
        });
    }

    protected processList(response: AxiosResponse): Promise<DeviceData[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DeviceData.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<DeviceData[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DeviceData[]>(null as any);
    }

    listUsages(projectId: string, accessTokenId?: string | null | undefined, serverFarmId?: string | null | undefined, usageBeginTime?: Date | null | undefined, usageEndTime?: Date | null | undefined, recordIndex?: number | undefined, recordCount?: number | undefined, cancelToken?: CancelToken): Promise<DeviceData[]> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/devices/usages?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (accessTokenId !== undefined && accessTokenId !== null)
            url_ += "accessTokenId=" + encodeURIComponent("" + accessTokenId) + "&";
        if (serverFarmId !== undefined && serverFarmId !== null)
            url_ += "serverFarmId=" + encodeURIComponent("" + serverFarmId) + "&";
        if (usageBeginTime !== undefined && usageBeginTime !== null)
            url_ += "usageBeginTime=" + encodeURIComponent(usageBeginTime ? "" + usageBeginTime.toISOString() : "") + "&";
        if (usageEndTime !== undefined && usageEndTime !== null)
            url_ += "usageEndTime=" + encodeURIComponent(usageEndTime ? "" + usageEndTime.toISOString() : "") + "&";
        if (recordIndex === null)
            throw new Error("The parameter 'recordIndex' cannot be null.");
        else if (recordIndex !== undefined)
            url_ += "recordIndex=" + encodeURIComponent("" + recordIndex) + "&";
        if (recordCount === null)
            throw new Error("The parameter 'recordCount' cannot be null.");
        else if (recordCount !== undefined)
            url_ += "recordCount=" + encodeURIComponent("" + recordCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processListUsages(_response);
        });
    }

    protected processListUsages(response: AxiosResponse): Promise<DeviceData[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DeviceData.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<DeviceData[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DeviceData[]>(null as any);
    }
}

export class FarmTokenReposClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    create(projectId: string, serverFarmId: string, createParams: FarmTokenRepoCreateParams, cancelToken?: CancelToken): Promise<FarmTokenRepo> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/server-farms/{serverFarmId}/farm-token-repos";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (serverFarmId === undefined || serverFarmId === null)
            throw new Error("The parameter 'serverFarmId' must be defined.");
        url_ = url_.replace("{serverFarmId}", encodeURIComponent("" + serverFarmId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createParams);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<FarmTokenRepo> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FarmTokenRepo.fromJS(resultData200);
            return Promise.resolve<FarmTokenRepo>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FarmTokenRepo>(null as any);
    }

    list(projectId: string, serverFarmId: string, checkStatus?: boolean | undefined, cancelToken?: CancelToken): Promise<FarmTokenRepo[]> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/server-farms/{serverFarmId}/farm-token-repos?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (serverFarmId === undefined || serverFarmId === null)
            throw new Error("The parameter 'serverFarmId' must be defined.");
        url_ = url_.replace("{serverFarmId}", encodeURIComponent("" + serverFarmId));
        if (checkStatus === null)
            throw new Error("The parameter 'checkStatus' cannot be null.");
        else if (checkStatus !== undefined)
            url_ += "checkStatus=" + encodeURIComponent("" + checkStatus) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processList(_response);
        });
    }

    protected processList(response: AxiosResponse): Promise<FarmTokenRepo[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FarmTokenRepo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<FarmTokenRepo[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FarmTokenRepo[]>(null as any);
    }

    getSummary(projectId: string, serverFarmId: string, cancelToken?: CancelToken): Promise<FarmTokenRepoSummary> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/server-farms/{serverFarmId}/farm-token-repos/Summary";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (serverFarmId === undefined || serverFarmId === null)
            throw new Error("The parameter 'serverFarmId' must be defined.");
        url_ = url_.replace("{serverFarmId}", encodeURIComponent("" + serverFarmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSummary(_response);
        });
    }

    protected processGetSummary(response: AxiosResponse): Promise<FarmTokenRepoSummary> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FarmTokenRepoSummary.fromJS(resultData200);
            return Promise.resolve<FarmTokenRepoSummary>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FarmTokenRepoSummary>(null as any);
    }

    get(projectId: string, serverFarmId: string, farmTokenRepoId: string, checkStatus?: boolean | undefined, cancelToken?: CancelToken): Promise<FarmTokenRepo> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/server-farms/{serverFarmId}/farm-token-repos/{farmTokenRepoId}?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (serverFarmId === undefined || serverFarmId === null)
            throw new Error("The parameter 'serverFarmId' must be defined.");
        url_ = url_.replace("{serverFarmId}", encodeURIComponent("" + serverFarmId));
        if (farmTokenRepoId === undefined || farmTokenRepoId === null)
            throw new Error("The parameter 'farmTokenRepoId' must be defined.");
        url_ = url_.replace("{farmTokenRepoId}", encodeURIComponent("" + farmTokenRepoId));
        if (checkStatus === null)
            throw new Error("The parameter 'checkStatus' cannot be null.");
        else if (checkStatus !== undefined)
            url_ += "checkStatus=" + encodeURIComponent("" + checkStatus) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<FarmTokenRepo> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FarmTokenRepo.fromJS(resultData200);
            return Promise.resolve<FarmTokenRepo>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FarmTokenRepo>(null as any);
    }

    update(projectId: string, serverFarmId: string, farmTokenRepoId: string, updateParams: FarmTokenRepoUpdateParams, cancelToken?: CancelToken): Promise<FarmTokenRepo> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/server-farms/{serverFarmId}/farm-token-repos/{farmTokenRepoId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (serverFarmId === undefined || serverFarmId === null)
            throw new Error("The parameter 'serverFarmId' must be defined.");
        url_ = url_.replace("{serverFarmId}", encodeURIComponent("" + serverFarmId));
        if (farmTokenRepoId === undefined || farmTokenRepoId === null)
            throw new Error("The parameter 'farmTokenRepoId' must be defined.");
        url_ = url_.replace("{farmTokenRepoId}", encodeURIComponent("" + farmTokenRepoId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateParams);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<FarmTokenRepo> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FarmTokenRepo.fromJS(resultData200);
            return Promise.resolve<FarmTokenRepo>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FarmTokenRepo>(null as any);
    }

    delete(projectId: string, serverFarmId: string, farmTokenRepoId: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/server-farms/{serverFarmId}/farm-token-repos/{farmTokenRepoId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (serverFarmId === undefined || serverFarmId === null)
            throw new Error("The parameter 'serverFarmId' must be defined.");
        url_ = url_.replace("{serverFarmId}", encodeURIComponent("" + serverFarmId));
        if (farmTokenRepoId === undefined || farmTokenRepoId === null)
            throw new Error("The parameter 'farmTokenRepoId' must be defined.");
        url_ = url_.replace("{farmTokenRepoId}", encodeURIComponent("" + farmTokenRepoId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class HealthClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    get(check: string, cancelToken?: CancelToken): Promise<string> {
        let url_ = this.baseUrl + "/api/v1/health/{check}";
        if (check === undefined || check === null)
            throw new Error("The parameter 'check' must be defined.");
        url_ = url_.replace("{check}", encodeURIComponent("" + check));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }
}

export class HostOrdersClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    getIp(projectId: string, ipAddress: string, cancelToken?: CancelToken): Promise<HostIp> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/host-orders/ips/{ipAddress}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (ipAddress === undefined || ipAddress === null)
            throw new Error("The parameter 'ipAddress' must be defined.");
        url_ = url_.replace("{ipAddress}", encodeURIComponent("" + ipAddress));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetIp(_response);
        });
    }

    protected processGetIp(response: AxiosResponse): Promise<HostIp> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = HostIp.fromJS(resultData200);
            return Promise.resolve<HostIp>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<HostIp>(null as any);
    }

    releaseIp(projectId: string, ipAddress: string, ignoreProviderError?: boolean | undefined, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/host-orders/ips/{ipAddress}?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (ipAddress === undefined || ipAddress === null)
            throw new Error("The parameter 'ipAddress' must be defined.");
        url_ = url_.replace("{ipAddress}", encodeURIComponent("" + ipAddress));
        if (ignoreProviderError === null)
            throw new Error("The parameter 'ignoreProviderError' cannot be null.");
        else if (ignoreProviderError !== undefined)
            url_ += "ignoreProviderError=" + encodeURIComponent("" + ignoreProviderError) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReleaseIp(_response);
        });
    }

    protected processReleaseIp(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    updateIp(projectId: string, ipAddress: string, updateParams: HostIpUpdateParams, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/host-orders/ips/{ipAddress}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (ipAddress === undefined || ipAddress === null)
            throw new Error("The parameter 'ipAddress' must be defined.");
        url_ = url_.replace("{ipAddress}", encodeURIComponent("" + ipAddress));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateParams);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateIp(_response);
        });
    }

    protected processUpdateIp(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    listIps(projectId: string, search?: string | null | undefined, recordIndex?: number | undefined, recordCount?: number | undefined, cancelToken?: CancelToken): Promise<HostIp[]> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/host-orders/ips?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (recordIndex === null)
            throw new Error("The parameter 'recordIndex' cannot be null.");
        else if (recordIndex !== undefined)
            url_ += "recordIndex=" + encodeURIComponent("" + recordIndex) + "&";
        if (recordCount === null)
            throw new Error("The parameter 'recordCount' cannot be null.");
        else if (recordCount !== undefined)
            url_ += "recordCount=" + encodeURIComponent("" + recordCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processListIps(_response);
        });
    }

    protected processListIps(response: AxiosResponse): Promise<HostIp[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(HostIp.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<HostIp[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<HostIp[]>(null as any);
    }

    createNewIpOrder(projectId: string, hostOrderNewIp: HostOrderNewIp, cancelToken?: CancelToken): Promise<HostOrder> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/host-orders/order-new-ip";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(hostOrderNewIp);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateNewIpOrder(_response);
        });
    }

    protected processCreateNewIpOrder(response: AxiosResponse): Promise<HostOrder> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = HostOrder.fromJS(resultData200);
            return Promise.resolve<HostOrder>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<HostOrder>(null as any);
    }

    list(projectId: string, search?: string | null | undefined, recordIndex?: number | undefined, recordCount?: number | undefined, cancelToken?: CancelToken): Promise<HostOrder[]> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/host-orders?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (recordIndex === null)
            throw new Error("The parameter 'recordIndex' cannot be null.");
        else if (recordIndex !== undefined)
            url_ += "recordIndex=" + encodeURIComponent("" + recordIndex) + "&";
        if (recordCount === null)
            throw new Error("The parameter 'recordCount' cannot be null.");
        else if (recordCount !== undefined)
            url_ += "recordCount=" + encodeURIComponent("" + recordCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processList(_response);
        });
    }

    protected processList(response: AxiosResponse): Promise<HostOrder[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(HostOrder.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<HostOrder[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<HostOrder[]>(null as any);
    }

    get(projectId: string, orderId: string, cancelToken?: CancelToken): Promise<HostOrder> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/host-orders/{orderId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (orderId === undefined || orderId === null)
            throw new Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<HostOrder> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = HostOrder.fromJS(resultData200);
            return Promise.resolve<HostOrder>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<HostOrder>(null as any);
    }
}

export class IpLocksClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    create(projectId: string, createParams: IpLockCreateParams, cancelToken?: CancelToken): Promise<IpLock> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/ip-locks";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createParams);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<IpLock> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IpLock.fromJS(resultData200);
            return Promise.resolve<IpLock>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IpLock>(null as any);
    }

    list(projectId: string, search?: string | null | undefined, recordIndex?: number | undefined, recordCount?: number | undefined, cancelToken?: CancelToken): Promise<IpLock[]> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/ip-locks?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (recordIndex === null)
            throw new Error("The parameter 'recordIndex' cannot be null.");
        else if (recordIndex !== undefined)
            url_ += "recordIndex=" + encodeURIComponent("" + recordIndex) + "&";
        if (recordCount === null)
            throw new Error("The parameter 'recordCount' cannot be null.");
        else if (recordCount !== undefined)
            url_ += "recordCount=" + encodeURIComponent("" + recordCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processList(_response);
        });
    }

    protected processList(response: AxiosResponse): Promise<IpLock[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IpLock.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<IpLock[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IpLock[]>(null as any);
    }

    update(projectId: string, ip: string, updateParams: IpLockUpdateParams, cancelToken?: CancelToken): Promise<IpLock> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/ip-locks/{ip}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (ip === undefined || ip === null)
            throw new Error("The parameter 'ip' must be defined.");
        url_ = url_.replace("{ip}", encodeURIComponent("" + ip));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateParams);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<IpLock> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IpLock.fromJS(resultData200);
            return Promise.resolve<IpLock>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IpLock>(null as any);
    }

    delete(projectId: string, ip: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/ip-locks/{ip}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (ip === undefined || ip === null)
            throw new Error("The parameter 'ip' must be defined.");
        url_ = url_.replace("{ip}", encodeURIComponent("" + ip));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    get(projectId: string, ip: string, cancelToken?: CancelToken): Promise<IpLock> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/ip-locks/{ip}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (ip === undefined || ip === null)
            throw new Error("The parameter 'ip' must be defined.");
        url_ = url_.replace("{ip}", encodeURIComponent("" + ip));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<IpLock> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IpLock.fromJS(resultData200);
            return Promise.resolve<IpLock>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IpLock>(null as any);
    }
}

export class ProjectsClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    create( cancelToken?: CancelToken): Promise<Project> {
        let url_ = this.baseUrl + "/api/v1/projects";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Project> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Project.fromJS(resultData200);
            return Promise.resolve<Project>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Project>(null as any);
    }

    list(search?: string | null | undefined, recordIndex?: number | undefined, recordCount?: number | undefined, cancelToken?: CancelToken): Promise<Project[]> {
        let url_ = this.baseUrl + "/api/v1/projects?";
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (recordIndex === null)
            throw new Error("The parameter 'recordIndex' cannot be null.");
        else if (recordIndex !== undefined)
            url_ += "recordIndex=" + encodeURIComponent("" + recordIndex) + "&";
        if (recordCount === null)
            throw new Error("The parameter 'recordCount' cannot be null.");
        else if (recordCount !== undefined)
            url_ += "recordCount=" + encodeURIComponent("" + recordCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processList(_response);
        });
    }

    protected processList(response: AxiosResponse): Promise<Project[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Project.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Project[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Project[]>(null as any);
    }

    get(projectId: string, cancelToken?: CancelToken): Promise<Project> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<Project> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Project.fromJS(resultData200);
            return Promise.resolve<Project>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Project>(null as any);
    }

    update(projectId: string, updateParams: ProjectUpdateParams, cancelToken?: CancelToken): Promise<Project> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateParams);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<Project> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Project.fromJS(resultData200);
            return Promise.resolve<Project>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Project>(null as any);
    }

    delete(projectId: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ReportClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    getUsage(projectId: string, usageBeginTime: Date | null, usageEndTime?: Date | null | undefined, serverFarmId?: string | null | undefined, serverId?: string | null | undefined, deviceId?: string | null | undefined, cancelToken?: CancelToken): Promise<Usage> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/report/usage?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (usageBeginTime === undefined)
            throw new Error("The parameter 'usageBeginTime' must be defined.");
        else if(usageBeginTime !== null)
            url_ += "usageBeginTime=" + encodeURIComponent(usageBeginTime ? "" + usageBeginTime.toISOString() : "") + "&";
        if (usageEndTime !== undefined && usageEndTime !== null)
            url_ += "usageEndTime=" + encodeURIComponent(usageEndTime ? "" + usageEndTime.toISOString() : "") + "&";
        if (serverFarmId !== undefined && serverFarmId !== null)
            url_ += "serverFarmId=" + encodeURIComponent("" + serverFarmId) + "&";
        if (serverId !== undefined && serverId !== null)
            url_ += "serverId=" + encodeURIComponent("" + serverId) + "&";
        if (deviceId !== undefined && deviceId !== null)
            url_ += "deviceId=" + encodeURIComponent("" + deviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUsage(_response);
        });
    }

    protected processGetUsage(response: AxiosResponse): Promise<Usage> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Usage.fromJS(resultData200);
            return Promise.resolve<Usage>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Usage>(null as any);
    }

    getServerStatusHistory(projectId: string, usageBeginTime: Date | null, usageEndTime?: Date | null | undefined, serverFarmId?: string | null | undefined, serverId?: string | null | undefined, cancelToken?: CancelToken): Promise<ServerStatusHistory[]> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/report/server-status-history?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (usageBeginTime === undefined)
            throw new Error("The parameter 'usageBeginTime' must be defined.");
        else if(usageBeginTime !== null)
            url_ += "usageBeginTime=" + encodeURIComponent(usageBeginTime ? "" + usageBeginTime.toISOString() : "") + "&";
        if (usageEndTime !== undefined && usageEndTime !== null)
            url_ += "usageEndTime=" + encodeURIComponent(usageEndTime ? "" + usageEndTime.toISOString() : "") + "&";
        if (serverFarmId !== undefined && serverFarmId !== null)
            url_ += "serverFarmId=" + encodeURIComponent("" + serverFarmId) + "&";
        if (serverId !== undefined && serverId !== null)
            url_ += "serverId=" + encodeURIComponent("" + serverId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetServerStatusHistory(_response);
        });
    }

    protected processGetServerStatusHistory(response: AxiosResponse): Promise<ServerStatusHistory[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ServerStatusHistory.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ServerStatusHistory[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ServerStatusHistory[]>(null as any);
    }
}

export class ServerFarmsClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    create(projectId: string, createParams: ServerFarmCreateParams, cancelToken?: CancelToken): Promise<ServerFarmData> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/server-farms";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createParams);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ServerFarmData> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ServerFarmData.fromJS(resultData200);
            return Promise.resolve<ServerFarmData>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ServerFarmData>(null as any);
    }

    list(projectId: string, search?: string | null | undefined, includeSummary?: boolean | undefined, recordIndex?: number | undefined, recordCount?: number | undefined, cancelToken?: CancelToken): Promise<ServerFarmData[]> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/server-farms?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (includeSummary === null)
            throw new Error("The parameter 'includeSummary' cannot be null.");
        else if (includeSummary !== undefined)
            url_ += "includeSummary=" + encodeURIComponent("" + includeSummary) + "&";
        if (recordIndex === null)
            throw new Error("The parameter 'recordIndex' cannot be null.");
        else if (recordIndex !== undefined)
            url_ += "recordIndex=" + encodeURIComponent("" + recordIndex) + "&";
        if (recordCount === null)
            throw new Error("The parameter 'recordCount' cannot be null.");
        else if (recordCount !== undefined)
            url_ += "recordCount=" + encodeURIComponent("" + recordCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processList(_response);
        });
    }

    protected processList(response: AxiosResponse): Promise<ServerFarmData[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ServerFarmData.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ServerFarmData[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ServerFarmData[]>(null as any);
    }

    update(projectId: string, serverFarmId: string, updateParams: ServerFarmUpdateParams, cancelToken?: CancelToken): Promise<ServerFarmData> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/server-farms/{serverFarmId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (serverFarmId === undefined || serverFarmId === null)
            throw new Error("The parameter 'serverFarmId' must be defined.");
        url_ = url_.replace("{serverFarmId}", encodeURIComponent("" + serverFarmId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateParams);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<ServerFarmData> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ServerFarmData.fromJS(resultData200);
            return Promise.resolve<ServerFarmData>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ServerFarmData>(null as any);
    }

    get(projectId: string, serverFarmId: string, includeSummary?: boolean | undefined, cancelToken?: CancelToken): Promise<ServerFarmData> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/server-farms/{serverFarmId}?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (serverFarmId === undefined || serverFarmId === null)
            throw new Error("The parameter 'serverFarmId' must be defined.");
        url_ = url_.replace("{serverFarmId}", encodeURIComponent("" + serverFarmId));
        if (includeSummary === null)
            throw new Error("The parameter 'includeSummary' cannot be null.");
        else if (includeSummary !== undefined)
            url_ += "includeSummary=" + encodeURIComponent("" + includeSummary) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ServerFarmData> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ServerFarmData.fromJS(resultData200);
            return Promise.resolve<ServerFarmData>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ServerFarmData>(null as any);
    }

    delete(projectId: string, serverFarmId: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/server-farms/{serverFarmId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (serverFarmId === undefined || serverFarmId === null)
            throw new Error("The parameter 'serverFarmId' must be defined.");
        url_ = url_.replace("{serverFarmId}", encodeURIComponent("" + serverFarmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    getEncryptedToken(projectId: string, serverFarmId: string, cancelToken?: CancelToken): Promise<string> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/server-farms/{serverFarmId}/encrypted-token";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (serverFarmId === undefined || serverFarmId === null)
            throw new Error("The parameter 'serverFarmId' must be defined.");
        url_ = url_.replace("{serverFarmId}", encodeURIComponent("" + serverFarmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetEncryptedToken(_response);
        });
    }

    protected processGetEncryptedToken(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    certificateImport(projectId: string, serverFarmId: string, importParams: CertificateImportParams, cancelToken?: CancelToken): Promise<Certificate> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/server-farms/{serverFarmId}/certificate/import";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (serverFarmId === undefined || serverFarmId === null)
            throw new Error("The parameter 'serverFarmId' must be defined.");
        url_ = url_.replace("{serverFarmId}", encodeURIComponent("" + serverFarmId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(importParams);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCertificateImport(_response);
        });
    }

    protected processCertificateImport(response: AxiosResponse): Promise<Certificate> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Certificate.fromJS(resultData200);
            return Promise.resolve<Certificate>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Certificate>(null as any);
    }

    certificateReplace(projectId: string, serverFarmId: string, createParams?: CertificateCreateParams | undefined, cancelToken?: CancelToken): Promise<Certificate> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/server-farms/{serverFarmId}/certificate/replace";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (serverFarmId === undefined || serverFarmId === null)
            throw new Error("The parameter 'serverFarmId' must be defined.");
        url_ = url_.replace("{serverFarmId}", encodeURIComponent("" + serverFarmId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createParams);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCertificateReplace(_response);
        });
    }

    protected processCertificateReplace(response: AxiosResponse): Promise<Certificate> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Certificate.fromJS(resultData200);
            return Promise.resolve<Certificate>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Certificate>(null as any);
    }

    certificateList(projectId: string, serverFarmId: string, cancelToken?: CancelToken): Promise<Certificate[]> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/server-farms/{serverFarmId}/certificates";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (serverFarmId === undefined || serverFarmId === null)
            throw new Error("The parameter 'serverFarmId' must be defined.");
        url_ = url_.replace("{serverFarmId}", encodeURIComponent("" + serverFarmId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCertificateList(_response);
        });
    }

    protected processCertificateList(response: AxiosResponse): Promise<Certificate[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Certificate.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Certificate[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Certificate[]>(null as any);
    }
}

export class ServerProfilesClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    create(projectId: string, createParams?: ServerProfileCreateParams | undefined, cancelToken?: CancelToken): Promise<ServerProfile> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/server-profiles";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createParams);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ServerProfile> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ServerProfile.fromJS(resultData200);
            return Promise.resolve<ServerProfile>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ServerProfile>(null as any);
    }

    list(projectId: string, search?: string | null | undefined, includeSummary?: boolean | undefined, recordIndex?: number | undefined, recordCount?: number | undefined, cancelToken?: CancelToken): Promise<ServerProfileData[]> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/server-profiles?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (includeSummary === null)
            throw new Error("The parameter 'includeSummary' cannot be null.");
        else if (includeSummary !== undefined)
            url_ += "includeSummary=" + encodeURIComponent("" + includeSummary) + "&";
        if (recordIndex === null)
            throw new Error("The parameter 'recordIndex' cannot be null.");
        else if (recordIndex !== undefined)
            url_ += "recordIndex=" + encodeURIComponent("" + recordIndex) + "&";
        if (recordCount === null)
            throw new Error("The parameter 'recordCount' cannot be null.");
        else if (recordCount !== undefined)
            url_ += "recordCount=" + encodeURIComponent("" + recordCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processList(_response);
        });
    }

    protected processList(response: AxiosResponse): Promise<ServerProfileData[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ServerProfileData.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ServerProfileData[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ServerProfileData[]>(null as any);
    }

    get(projectId: string, serverProfileId: string, includeSummary?: boolean | undefined, cancelToken?: CancelToken): Promise<ServerProfileData> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/server-profiles/{serverProfileId}?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (serverProfileId === undefined || serverProfileId === null)
            throw new Error("The parameter 'serverProfileId' must be defined.");
        url_ = url_.replace("{serverProfileId}", encodeURIComponent("" + serverProfileId));
        if (includeSummary === null)
            throw new Error("The parameter 'includeSummary' cannot be null.");
        else if (includeSummary !== undefined)
            url_ += "includeSummary=" + encodeURIComponent("" + includeSummary) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ServerProfileData> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ServerProfileData.fromJS(resultData200);
            return Promise.resolve<ServerProfileData>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ServerProfileData>(null as any);
    }

    update(projectId: string, serverProfileId: string, updateParams: ServerProfileUpdateParams, cancelToken?: CancelToken): Promise<ServerProfile> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/server-profiles/{serverProfileId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (serverProfileId === undefined || serverProfileId === null)
            throw new Error("The parameter 'serverProfileId' must be defined.");
        url_ = url_.replace("{serverProfileId}", encodeURIComponent("" + serverProfileId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateParams);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<ServerProfile> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ServerProfile.fromJS(resultData200);
            return Promise.resolve<ServerProfile>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ServerProfile>(null as any);
    }

    delete(projectId: string, serverProfileId: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/server-profiles/{serverProfileId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (serverProfileId === undefined || serverProfileId === null)
            throw new Error("The parameter 'serverProfileId' must be defined.");
        url_ = url_.replace("{serverProfileId}", encodeURIComponent("" + serverProfileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ServersClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    create(projectId: string, createParams: ServerCreateParams, cancelToken?: CancelToken): Promise<ServerData> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/servers";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createParams);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ServerData> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ServerData.fromJS(resultData200);
            return Promise.resolve<ServerData>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ServerData>(null as any);
    }

    list(projectId: string, search?: string | null | undefined, serverId?: string | null | undefined, serverFarmId?: string | null | undefined, ipAddress?: string | null | undefined, recordIndex?: number | undefined, recordCount?: number | undefined, cancelToken?: CancelToken): Promise<ServerData[]> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/servers?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (serverId !== undefined && serverId !== null)
            url_ += "serverId=" + encodeURIComponent("" + serverId) + "&";
        if (serverFarmId !== undefined && serverFarmId !== null)
            url_ += "serverFarmId=" + encodeURIComponent("" + serverFarmId) + "&";
        if (ipAddress !== undefined && ipAddress !== null)
            url_ += "ipAddress=" + encodeURIComponent("" + ipAddress) + "&";
        if (recordIndex === null)
            throw new Error("The parameter 'recordIndex' cannot be null.");
        else if (recordIndex !== undefined)
            url_ += "recordIndex=" + encodeURIComponent("" + recordIndex) + "&";
        if (recordCount === null)
            throw new Error("The parameter 'recordCount' cannot be null.");
        else if (recordCount !== undefined)
            url_ += "recordCount=" + encodeURIComponent("" + recordCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processList(_response);
        });
    }

    protected processList(response: AxiosResponse): Promise<ServerData[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ServerData.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ServerData[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ServerData[]>(null as any);
    }

    update(projectId: string, serverId: string, updateParams: ServerUpdateParams, cancelToken?: CancelToken): Promise<ServerData> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/servers/{serverId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (serverId === undefined || serverId === null)
            throw new Error("The parameter 'serverId' must be defined.");
        url_ = url_.replace("{serverId}", encodeURIComponent("" + serverId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateParams);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<ServerData> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ServerData.fromJS(resultData200);
            return Promise.resolve<ServerData>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ServerData>(null as any);
    }

    get(projectId: string, serverId: string, cancelToken?: CancelToken): Promise<ServerData> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/servers/{serverId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (serverId === undefined || serverId === null)
            throw new Error("The parameter 'serverId' must be defined.");
        url_ = url_.replace("{serverId}", encodeURIComponent("" + serverId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<ServerData> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ServerData.fromJS(resultData200);
            return Promise.resolve<ServerData>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ServerData>(null as any);
    }

    delete(projectId: string, serverId: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/servers/{serverId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (serverId === undefined || serverId === null)
            throw new Error("The parameter 'serverId' must be defined.");
        url_ = url_.replace("{serverId}", encodeURIComponent("" + serverId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    reconfigure(projectId: string, serverId: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/servers/{serverId}/reconfigure";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (serverId === undefined || serverId === null)
            throw new Error("The parameter 'serverId' must be defined.");
        url_ = url_.replace("{serverId}", encodeURIComponent("" + serverId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReconfigure(_response);
        });
    }

    protected processReconfigure(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    installBySshUserPassword(projectId: string, serverId: string, installParams: ServerInstallBySshUserPasswordParams, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/servers/{serverId}/install-by-ssh-user-password";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (serverId === undefined || serverId === null)
            throw new Error("The parameter 'serverId' must be defined.");
        url_ = url_.replace("{serverId}", encodeURIComponent("" + serverId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(installParams);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processInstallBySshUserPassword(_response);
        });
    }

    protected processInstallBySshUserPassword(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    installBySshUserKey(projectId: string, serverId: string, installParams: ServerInstallBySshUserKeyParams, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/servers/{serverId}/install-by-ssh-user-key";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (serverId === undefined || serverId === null)
            throw new Error("The parameter 'serverId' must be defined.");
        url_ = url_.replace("{serverId}", encodeURIComponent("" + serverId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(installParams);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processInstallBySshUserKey(_response);
        });
    }

    protected processInstallBySshUserKey(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    getInstallManual(projectId: string, serverId: string, cancelToken?: CancelToken): Promise<ServerInstallManual> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/servers/{serverId}/install/manual";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (serverId === undefined || serverId === null)
            throw new Error("The parameter 'serverId' must be defined.");
        url_ = url_.replace("{serverId}", encodeURIComponent("" + serverId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetInstallManual(_response);
        });
    }

    protected processGetInstallManual(response: AxiosResponse): Promise<ServerInstallManual> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ServerInstallManual.fromJS(resultData200);
            return Promise.resolve<ServerInstallManual>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ServerInstallManual>(null as any);
    }

    getStatusSummary(projectId: string, serverFarmId?: string | null | undefined, serverId?: string | null | undefined, cancelToken?: CancelToken): Promise<ServersStatusSummary> {
        let url_ = this.baseUrl + "/api/v1/projects/{projectId}/servers/status-summary?";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (serverFarmId !== undefined && serverFarmId !== null)
            url_ += "serverFarmId=" + encodeURIComponent("" + serverFarmId) + "&";
        if (serverId !== undefined && serverId !== null)
            url_ += "serverId=" + encodeURIComponent("" + serverId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetStatusSummary(_response);
        });
    }

    protected processGetStatusSummary(response: AxiosResponse): Promise<ServersStatusSummary> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ServersStatusSummary.fromJS(resultData200);
            return Promise.resolve<ServersStatusSummary>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ServersStatusSummary>(null as any);
    }
}

export class SystemClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    sync( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/system";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSync(_response);
        });
    }

    protected processSync(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class TeamClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    listCurrentUserProjects( cancelToken?: CancelToken): Promise<Project[]> {
        let url_ = this.baseUrl + "/api/v1/team/users/current/projects";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processListCurrentUserProjects(_response);
        });
    }

    protected processListCurrentUserProjects(response: AxiosResponse): Promise<Project[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Project.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Project[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Project[]>(null as any);
    }

    listCurrentUserResources( cancelToken?: CancelToken): Promise<string[]> {
        let url_ = this.baseUrl + "/api/v1/team/users/current/resources";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processListCurrentUserResources(_response);
        });
    }

    protected processListCurrentUserResources(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<string[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(null as any);
    }

    listCurrentUserPermissions(resourceId: string, cancelToken?: CancelToken): Promise<string[]> {
        let url_ = this.baseUrl + "/api/v1/team/users/current/resources/{resourceId}/permissions";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processListCurrentUserPermissions(_response);
        });
    }

    protected processListCurrentUserPermissions(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<string[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(null as any);
    }

    resetBotApiKey(userId: string, cancelToken?: CancelToken): Promise<ApiKey> {
        let url_ = this.baseUrl + "/api/v1/team/users/{userId}/bot/reset-api-key";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processResetBotApiKey(_response);
        });
    }

    protected processResetBotApiKey(response: AxiosResponse): Promise<ApiKey> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiKey.fromJS(resultData200);
            return Promise.resolve<ApiKey>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiKey>(null as any);
    }

    updateBot(userId: string, updateParam: TeamUpdateBotParam, cancelToken?: CancelToken): Promise<User> {
        let url_ = this.baseUrl + "/api/v1/team/users/{userId}/bot";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateParam);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PATCH",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateBot(_response);
        });
    }

    protected processUpdateBot(response: AxiosResponse): Promise<User> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = User.fromJS(resultData200);
            return Promise.resolve<User>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<User>(null as any);
    }

    listRoles(resourceId: string, cancelToken?: CancelToken): Promise<Role[]> {
        let url_ = this.baseUrl + "/api/v1/team/resources/{resourceId}/roles";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processListRoles(_response);
        });
    }

    protected processListRoles(response: AxiosResponse): Promise<Role[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Role.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Role[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Role[]>(null as any);
    }

    listUserRoles(resourceId: string, roleId?: string | null | undefined, userId?: string | null | undefined, search?: string | null | undefined, isBot?: boolean | null | undefined, recordIndex?: number | undefined, recordCount?: number | null | undefined, cancelToken?: CancelToken): Promise<ListResultOfUserRole> {
        let url_ = this.baseUrl + "/api/v1/team/resources/{resourceId}/user-roles?";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        if (roleId !== undefined && roleId !== null)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&";
        if (userId !== undefined && userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (search !== undefined && search !== null)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        if (isBot !== undefined && isBot !== null)
            url_ += "isBot=" + encodeURIComponent("" + isBot) + "&";
        if (recordIndex === null)
            throw new Error("The parameter 'recordIndex' cannot be null.");
        else if (recordIndex !== undefined)
            url_ += "recordIndex=" + encodeURIComponent("" + recordIndex) + "&";
        if (recordCount !== undefined && recordCount !== null)
            url_ += "recordCount=" + encodeURIComponent("" + recordCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processListUserRoles(_response);
        });
    }

    protected processListUserRoles(response: AxiosResponse): Promise<ListResultOfUserRole> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ListResultOfUserRole.fromJS(resultData200);
            return Promise.resolve<ListResultOfUserRole>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ListResultOfUserRole>(null as any);
    }

    getUser(resourceId: string, userId: string, cancelToken?: CancelToken): Promise<TeamUserOfUserAndUserRoleAndRole> {
        let url_ = this.baseUrl + "/api/v1/team/resources/{resourceId}/users/{userId}";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUser(_response);
        });
    }

    protected processGetUser(response: AxiosResponse): Promise<TeamUserOfUserAndUserRoleAndRole> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TeamUserOfUserAndUserRoleAndRole.fromJS(resultData200);
            return Promise.resolve<TeamUserOfUserAndUserRoleAndRole>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TeamUserOfUserAndUserRoleAndRole>(null as any);
    }

    getUserByEmail(resourceId: string, email: string, cancelToken?: CancelToken): Promise<TeamUserOfUserAndUserRoleAndRole> {
        let url_ = this.baseUrl + "/api/v1/team/resources/{resourceId}/users/email:{email}";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined.");
        url_ = url_.replace("{email}", encodeURIComponent("" + email));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUserByEmail(_response);
        });
    }

    protected processGetUserByEmail(response: AxiosResponse): Promise<TeamUserOfUserAndUserRoleAndRole> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TeamUserOfUserAndUserRoleAndRole.fromJS(resultData200);
            return Promise.resolve<TeamUserOfUserAndUserRoleAndRole>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TeamUserOfUserAndUserRoleAndRole>(null as any);
    }

    addNewBot(resourceId: string, roleId: string, addParam: TeamAddBotParam, cancelToken?: CancelToken): Promise<ApiKey> {
        let url_ = this.baseUrl + "/api/v1/team/resources/{resourceId}/roles/{roleId}/bots";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(addParam);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddNewBot(_response);
        });
    }

    protected processAddNewBot(response: AxiosResponse): Promise<ApiKey> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiKey.fromJS(resultData200);
            return Promise.resolve<ApiKey>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiKey>(null as any);
    }

    addUserByEmail(resourceId: string, roleId: string, email: string, addParam?: TeamAddEmailParam | undefined, cancelToken?: CancelToken): Promise<UserRole> {
        let url_ = this.baseUrl + "/api/v1/team/resources/{resourceId}/roles/{roleId}/users/email:{email}";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined.");
        url_ = url_.replace("{email}", encodeURIComponent("" + email));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(addParam);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddUserByEmail(_response);
        });
    }

    protected processAddUserByEmail(response: AxiosResponse): Promise<UserRole> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserRole.fromJS(resultData200);
            return Promise.resolve<UserRole>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserRole>(null as any);
    }

    addUser(resourceId: string, roleId: string, userId: string, cancelToken?: CancelToken): Promise<UserRole> {
        let url_ = this.baseUrl + "/api/v1/team/resources/{resourceId}/roles/{roleId}/users/{userId}";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddUser(_response);
        });
    }

    protected processAddUser(response: AxiosResponse): Promise<UserRole> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserRole.fromJS(resultData200);
            return Promise.resolve<UserRole>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserRole>(null as any);
    }

    removeUser(resourceId: string, roleId: string, userId: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/team/resources/{resourceId}/roles/{roleId}/users/{userId}";
        if (resourceId === undefined || resourceId === null)
            throw new Error("The parameter 'resourceId' must be defined.");
        url_ = url_.replace("{resourceId}", encodeURIComponent("" + resourceId));
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRemoveUser(_response);
        });
    }

    protected processRemoveUser(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    createSystemApiKey(secret: string, cancelToken?: CancelToken): Promise<ApiKey> {
        let url_ = this.baseUrl + "/api/v1/team/system/api-key";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (secret === null || secret === undefined)
            throw new Error("The parameter 'secret' cannot be null.");
        else
            content_.append("secret", secret.toString());

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateSystemApiKey(_response);
        });
    }

    protected processCreateSystemApiKey(response: AxiosResponse): Promise<ApiKey> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiKey.fromJS(resultData200);
            return Promise.resolve<ApiKey>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiKey>(null as any);
    }
}

export class AuthenticationClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    getCurrentUser( cancelToken?: CancelToken): Promise<User> {
        let url_ = this.baseUrl + "/api/v1/authentication/current";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCurrentUser(_response);
        });
    }

    protected processGetCurrentUser(response: AxiosResponse): Promise<User> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = User.fromJS(resultData200);
            return Promise.resolve<User>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<User>(null as any);
    }

    signOutAll( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/authentication/current/signout-all";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSignOutAll(_response);
        });
    }

    protected processSignOutAll(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    resetCurrentUserApiKey( cancelToken?: CancelToken): Promise<ApiKey> {
        let url_ = this.baseUrl + "/api/v1/authentication/current/reset-api-key";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processResetCurrentUserApiKey(_response);
        });
    }

    protected processResetCurrentUserApiKey(response: AxiosResponse): Promise<ApiKey> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiKey.fromJS(resultData200);
            return Promise.resolve<ApiKey>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiKey>(null as any);
    }

    signIn(request: SignInRequest, cancelToken?: CancelToken): Promise<ApiKey> {
        let url_ = this.baseUrl + "/api/v1/authentication/signin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSignIn(_response);
        });
    }

    protected processSignIn(response: AxiosResponse): Promise<ApiKey> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiKey.fromJS(resultData200);
            return Promise.resolve<ApiKey>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiKey>(null as any);
    }

    signUp(request: SignUpRequest, cancelToken?: CancelToken): Promise<ApiKey> {
        let url_ = this.baseUrl + "/api/v1/authentication/signup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSignUp(_response);
        });
    }

    protected processSignUp(response: AxiosResponse): Promise<ApiKey> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiKey.fromJS(resultData200);
            return Promise.resolve<ApiKey>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiKey>(null as any);
    }

    refreshToken(request: RefreshTokenRequest, cancelToken?: CancelToken): Promise<ApiKey> {
        let url_ = this.baseUrl + "/api/v1/authentication/refresh-token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRefreshToken(_response);
        });
    }

    protected processRefreshToken(response: AxiosResponse): Promise<ApiKey> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApiKey.fromJS(resultData200);
            return Promise.resolve<ApiKey>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApiKey>(null as any);
    }

    googleSignInHandler( cancelToken?: CancelToken): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/v1/authentication/external/google/signin-handler";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGoogleSignInHandler(_response);
        });
    }

    protected processGoogleSignInHandler(response: AxiosResponse): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse | null>(null as any);
    }

    getGoogleSignInUrl(csrfToken: string, nonce?: string | null | undefined, cancelToken?: CancelToken): Promise<string> {
        let url_ = this.baseUrl + "/api/v1/authentication/external/google/signin-url?";
        if (csrfToken === undefined || csrfToken === null)
            throw new Error("The parameter 'csrfToken' must be defined and cannot be null.");
        else
            url_ += "csrfToken=" + encodeURIComponent("" + csrfToken) + "&";
        if (nonce !== undefined && nonce !== null)
            url_ += "nonce=" + encodeURIComponent("" + nonce) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetGoogleSignInUrl(_response);
        });
    }

    protected processGetGoogleSignInUrl(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }
}

export class AccessData implements IAccessData {
    access!: Access;
    accessToken!: AccessToken;
    device?: Device | null;

    constructor(data?: IAccessData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.access = new Access();
            this.accessToken = new AccessToken();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.access = _data["access"] ? Access.fromJS(_data["access"]) : new Access();
            this.accessToken = _data["accessToken"] ? AccessToken.fromJS(_data["accessToken"]) : new AccessToken();
            this.device = _data["device"] ? Device.fromJS(_data["device"]) : <any>null;
        }
    }

    static fromJS(data: any): AccessData {
        data = typeof data === 'object' ? data : {};
        let result = new AccessData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["access"] = this.access ? this.access.toJSON() : <any>null;
        data["accessToken"] = this.accessToken ? this.accessToken.toJSON() : <any>null;
        data["device"] = this.device ? this.device.toJSON() : <any>null;
        return data;
    }
}

export interface IAccessData {
    access: Access;
    accessToken: AccessToken;
    device?: Device | null;
}

export class Access implements IAccess {
    accessId!: string;
    accessTokenId!: string;
    createdTime!: Date;
    lastUsedTime!: Date;
    description?: string | null;
    cycleSentTraffic!: number;
    cycleReceivedTraffic!: number;
    cycleTraffic!: number;
    totalSentTraffic!: number;
    totalReceivedTraffic!: number;
    totalTraffic!: number;

    constructor(data?: IAccess) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessId = _data["accessId"] !== undefined ? _data["accessId"] : <any>null;
            this.accessTokenId = _data["accessTokenId"] !== undefined ? _data["accessTokenId"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.lastUsedTime = _data["lastUsedTime"] ? new Date(_data["lastUsedTime"].toString()) : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.cycleSentTraffic = _data["cycleSentTraffic"] !== undefined ? _data["cycleSentTraffic"] : <any>null;
            this.cycleReceivedTraffic = _data["cycleReceivedTraffic"] !== undefined ? _data["cycleReceivedTraffic"] : <any>null;
            this.cycleTraffic = _data["cycleTraffic"] !== undefined ? _data["cycleTraffic"] : <any>null;
            this.totalSentTraffic = _data["totalSentTraffic"] !== undefined ? _data["totalSentTraffic"] : <any>null;
            this.totalReceivedTraffic = _data["totalReceivedTraffic"] !== undefined ? _data["totalReceivedTraffic"] : <any>null;
            this.totalTraffic = _data["totalTraffic"] !== undefined ? _data["totalTraffic"] : <any>null;
        }
    }

    static fromJS(data: any): Access {
        data = typeof data === 'object' ? data : {};
        let result = new Access();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessId"] = this.accessId !== undefined ? this.accessId : <any>null;
        data["accessTokenId"] = this.accessTokenId !== undefined ? this.accessTokenId : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["lastUsedTime"] = this.lastUsedTime ? this.lastUsedTime.toISOString() : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["cycleSentTraffic"] = this.cycleSentTraffic !== undefined ? this.cycleSentTraffic : <any>null;
        data["cycleReceivedTraffic"] = this.cycleReceivedTraffic !== undefined ? this.cycleReceivedTraffic : <any>null;
        data["cycleTraffic"] = this.cycleTraffic !== undefined ? this.cycleTraffic : <any>null;
        data["totalSentTraffic"] = this.totalSentTraffic !== undefined ? this.totalSentTraffic : <any>null;
        data["totalReceivedTraffic"] = this.totalReceivedTraffic !== undefined ? this.totalReceivedTraffic : <any>null;
        data["totalTraffic"] = this.totalTraffic !== undefined ? this.totalTraffic : <any>null;
        return data;
    }
}

export interface IAccess {
    accessId: string;
    accessTokenId: string;
    createdTime: Date;
    lastUsedTime: Date;
    description?: string | null;
    cycleSentTraffic: number;
    cycleReceivedTraffic: number;
    cycleTraffic: number;
    totalSentTraffic: number;
    totalReceivedTraffic: number;
    totalTraffic: number;
}

export class AccessToken implements IAccessToken {
    projectId!: string;
    accessTokenId!: string;
    accessTokenName?: string | null;
    supportCode!: number;
    serverFarmId!: string;
    serverFarmName?: string | null;
    maxTraffic!: number;
    lifetime!: number;
    maxDevice!: number;
    firstUsedTime?: Date | null;
    lastUsedTime?: Date | null;
    isPublic!: boolean;
    isEnabled!: boolean;
    adRequirement!: AdRequirement;
    expirationTime?: Date | null;
    createdTime!: Date;
    modifiedTime!: Date;
    description?: string | null;

    constructor(data?: IAccessToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectId = _data["projectId"] !== undefined ? _data["projectId"] : <any>null;
            this.accessTokenId = _data["accessTokenId"] !== undefined ? _data["accessTokenId"] : <any>null;
            this.accessTokenName = _data["accessTokenName"] !== undefined ? _data["accessTokenName"] : <any>null;
            this.supportCode = _data["supportCode"] !== undefined ? _data["supportCode"] : <any>null;
            this.serverFarmId = _data["serverFarmId"] !== undefined ? _data["serverFarmId"] : <any>null;
            this.serverFarmName = _data["serverFarmName"] !== undefined ? _data["serverFarmName"] : <any>null;
            this.maxTraffic = _data["maxTraffic"] !== undefined ? _data["maxTraffic"] : <any>null;
            this.lifetime = _data["lifetime"] !== undefined ? _data["lifetime"] : <any>null;
            this.maxDevice = _data["maxDevice"] !== undefined ? _data["maxDevice"] : <any>null;
            this.firstUsedTime = _data["firstUsedTime"] ? new Date(_data["firstUsedTime"].toString()) : <any>null;
            this.lastUsedTime = _data["lastUsedTime"] ? new Date(_data["lastUsedTime"].toString()) : <any>null;
            this.isPublic = _data["isPublic"] !== undefined ? _data["isPublic"] : <any>null;
            this.isEnabled = _data["isEnabled"] !== undefined ? _data["isEnabled"] : <any>null;
            this.adRequirement = _data["adRequirement"] !== undefined ? _data["adRequirement"] : <any>null;
            this.expirationTime = _data["expirationTime"] ? new Date(_data["expirationTime"].toString()) : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.modifiedTime = _data["modifiedTime"] ? new Date(_data["modifiedTime"].toString()) : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
        }
    }

    static fromJS(data: any): AccessToken {
        data = typeof data === 'object' ? data : {};
        let result = new AccessToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId !== undefined ? this.projectId : <any>null;
        data["accessTokenId"] = this.accessTokenId !== undefined ? this.accessTokenId : <any>null;
        data["accessTokenName"] = this.accessTokenName !== undefined ? this.accessTokenName : <any>null;
        data["supportCode"] = this.supportCode !== undefined ? this.supportCode : <any>null;
        data["serverFarmId"] = this.serverFarmId !== undefined ? this.serverFarmId : <any>null;
        data["serverFarmName"] = this.serverFarmName !== undefined ? this.serverFarmName : <any>null;
        data["maxTraffic"] = this.maxTraffic !== undefined ? this.maxTraffic : <any>null;
        data["lifetime"] = this.lifetime !== undefined ? this.lifetime : <any>null;
        data["maxDevice"] = this.maxDevice !== undefined ? this.maxDevice : <any>null;
        data["firstUsedTime"] = this.firstUsedTime ? this.firstUsedTime.toISOString() : <any>null;
        data["lastUsedTime"] = this.lastUsedTime ? this.lastUsedTime.toISOString() : <any>null;
        data["isPublic"] = this.isPublic !== undefined ? this.isPublic : <any>null;
        data["isEnabled"] = this.isEnabled !== undefined ? this.isEnabled : <any>null;
        data["adRequirement"] = this.adRequirement !== undefined ? this.adRequirement : <any>null;
        data["expirationTime"] = this.expirationTime ? this.expirationTime.toISOString() : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["modifiedTime"] = this.modifiedTime ? this.modifiedTime.toISOString() : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data;
    }
}

export interface IAccessToken {
    projectId: string;
    accessTokenId: string;
    accessTokenName?: string | null;
    supportCode: number;
    serverFarmId: string;
    serverFarmName?: string | null;
    maxTraffic: number;
    lifetime: number;
    maxDevice: number;
    firstUsedTime?: Date | null;
    lastUsedTime?: Date | null;
    isPublic: boolean;
    isEnabled: boolean;
    adRequirement: AdRequirement;
    expirationTime?: Date | null;
    createdTime: Date;
    modifiedTime: Date;
    description?: string | null;
}

export enum AdRequirement {
    None = "None",
    Flexible = "Flexible",
    Required = "Required",
}

export class Device implements IDevice {
    deviceId!: string;
    clientId!: string;
    clientVersion?: string | null;
    ipAddress?: string | null;
    country?: string | null;
    userAgent?: string | null;
    createdTime!: Date;
    modifiedTime!: Date;
    lockedTime?: Date | null;
    osName!: string;

    constructor(data?: IDevice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"] !== undefined ? _data["deviceId"] : <any>null;
            this.clientId = _data["clientId"] !== undefined ? _data["clientId"] : <any>null;
            this.clientVersion = _data["clientVersion"] !== undefined ? _data["clientVersion"] : <any>null;
            this.ipAddress = _data["ipAddress"] !== undefined ? _data["ipAddress"] : <any>null;
            this.country = _data["country"] !== undefined ? _data["country"] : <any>null;
            this.userAgent = _data["userAgent"] !== undefined ? _data["userAgent"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.modifiedTime = _data["modifiedTime"] ? new Date(_data["modifiedTime"].toString()) : <any>null;
            this.lockedTime = _data["lockedTime"] ? new Date(_data["lockedTime"].toString()) : <any>null;
            this.osName = _data["osName"] !== undefined ? _data["osName"] : <any>null;
        }
    }

    static fromJS(data: any): Device {
        data = typeof data === 'object' ? data : {};
        let result = new Device();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId !== undefined ? this.deviceId : <any>null;
        data["clientId"] = this.clientId !== undefined ? this.clientId : <any>null;
        data["clientVersion"] = this.clientVersion !== undefined ? this.clientVersion : <any>null;
        data["ipAddress"] = this.ipAddress !== undefined ? this.ipAddress : <any>null;
        data["country"] = this.country !== undefined ? this.country : <any>null;
        data["userAgent"] = this.userAgent !== undefined ? this.userAgent : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["modifiedTime"] = this.modifiedTime ? this.modifiedTime.toISOString() : <any>null;
        data["lockedTime"] = this.lockedTime ? this.lockedTime.toISOString() : <any>null;
        data["osName"] = this.osName !== undefined ? this.osName : <any>null;
        return data;
    }
}

export interface IDevice {
    deviceId: string;
    clientId: string;
    clientVersion?: string | null;
    ipAddress?: string | null;
    country?: string | null;
    userAgent?: string | null;
    createdTime: Date;
    modifiedTime: Date;
    lockedTime?: Date | null;
    osName: string;
}

export class ListResultOfAccessData implements IListResultOfAccessData {
    totalCount?: number | null;
    items!: AccessData[];

    constructor(data?: IListResultOfAccessData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AccessData.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
        }
    }

    static fromJS(data: any): ListResultOfAccessData {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultOfAccessData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultOfAccessData {
    totalCount?: number | null;
    items: AccessData[];
}

export class AccessTokenCreateParams implements IAccessTokenCreateParams {
    accessTokenId?: string | null;
    serverFarmId!: string;
    accessTokenName?: string | null;
    secret?: string | null;
    maxTraffic!: number;
    lifetime!: number;
    maxDevice!: number;
    expirationTime?: Date | null;
    isEnabled?: boolean | null;
    isPublic!: boolean;
    adRequirement!: AdRequirement;
    description?: string | null;

    constructor(data?: IAccessTokenCreateParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessTokenId = _data["accessTokenId"] !== undefined ? _data["accessTokenId"] : <any>null;
            this.serverFarmId = _data["serverFarmId"] !== undefined ? _data["serverFarmId"] : <any>null;
            this.accessTokenName = _data["accessTokenName"] !== undefined ? _data["accessTokenName"] : <any>null;
            this.secret = _data["secret"] !== undefined ? _data["secret"] : <any>null;
            this.maxTraffic = _data["maxTraffic"] !== undefined ? _data["maxTraffic"] : <any>null;
            this.lifetime = _data["lifetime"] !== undefined ? _data["lifetime"] : <any>null;
            this.maxDevice = _data["maxDevice"] !== undefined ? _data["maxDevice"] : <any>null;
            this.expirationTime = _data["expirationTime"] ? new Date(_data["expirationTime"].toString()) : <any>null;
            this.isEnabled = _data["isEnabled"] !== undefined ? _data["isEnabled"] : <any>null;
            this.isPublic = _data["isPublic"] !== undefined ? _data["isPublic"] : <any>null;
            this.adRequirement = _data["adRequirement"] !== undefined ? _data["adRequirement"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
        }
    }

    static fromJS(data: any): AccessTokenCreateParams {
        data = typeof data === 'object' ? data : {};
        let result = new AccessTokenCreateParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessTokenId"] = this.accessTokenId !== undefined ? this.accessTokenId : <any>null;
        data["serverFarmId"] = this.serverFarmId !== undefined ? this.serverFarmId : <any>null;
        data["accessTokenName"] = this.accessTokenName !== undefined ? this.accessTokenName : <any>null;
        data["secret"] = this.secret !== undefined ? this.secret : <any>null;
        data["maxTraffic"] = this.maxTraffic !== undefined ? this.maxTraffic : <any>null;
        data["lifetime"] = this.lifetime !== undefined ? this.lifetime : <any>null;
        data["maxDevice"] = this.maxDevice !== undefined ? this.maxDevice : <any>null;
        data["expirationTime"] = this.expirationTime ? this.expirationTime.toISOString() : <any>null;
        data["isEnabled"] = this.isEnabled !== undefined ? this.isEnabled : <any>null;
        data["isPublic"] = this.isPublic !== undefined ? this.isPublic : <any>null;
        data["adRequirement"] = this.adRequirement !== undefined ? this.adRequirement : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data;
    }
}

export interface IAccessTokenCreateParams {
    accessTokenId?: string | null;
    serverFarmId: string;
    accessTokenName?: string | null;
    secret?: string | null;
    maxTraffic: number;
    lifetime: number;
    maxDevice: number;
    expirationTime?: Date | null;
    isEnabled?: boolean | null;
    isPublic: boolean;
    adRequirement: AdRequirement;
    description?: string | null;
}

export class AccessTokenUpdateParams implements IAccessTokenUpdateParams {
    accessTokenName?: PatchOfString | null;
    serverFarmId?: PatchOfGuid | null;
    expirationTime?: PatchOfNullableDateTime | null;
    lifetime?: PatchOfInteger | null;
    maxDevice?: PatchOfInteger | null;
    maxTraffic?: PatchOfLong | null;
    isEnabled?: PatchOfBoolean | null;
    adRequirement?: PatchOfAdRequirement | null;
    description?: PatchOfString | null;

    constructor(data?: IAccessTokenUpdateParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessTokenName = _data["accessTokenName"] ? PatchOfString.fromJS(_data["accessTokenName"]) : <any>null;
            this.serverFarmId = _data["serverFarmId"] ? PatchOfGuid.fromJS(_data["serverFarmId"]) : <any>null;
            this.expirationTime = _data["expirationTime"] ? PatchOfNullableDateTime.fromJS(_data["expirationTime"]) : <any>null;
            this.lifetime = _data["lifetime"] ? PatchOfInteger.fromJS(_data["lifetime"]) : <any>null;
            this.maxDevice = _data["maxDevice"] ? PatchOfInteger.fromJS(_data["maxDevice"]) : <any>null;
            this.maxTraffic = _data["maxTraffic"] ? PatchOfLong.fromJS(_data["maxTraffic"]) : <any>null;
            this.isEnabled = _data["isEnabled"] ? PatchOfBoolean.fromJS(_data["isEnabled"]) : <any>null;
            this.adRequirement = _data["adRequirement"] ? PatchOfAdRequirement.fromJS(_data["adRequirement"]) : <any>null;
            this.description = _data["description"] ? PatchOfString.fromJS(_data["description"]) : <any>null;
        }
    }

    static fromJS(data: any): AccessTokenUpdateParams {
        data = typeof data === 'object' ? data : {};
        let result = new AccessTokenUpdateParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessTokenName"] = this.accessTokenName ? this.accessTokenName.toJSON() : <any>null;
        data["serverFarmId"] = this.serverFarmId ? this.serverFarmId.toJSON() : <any>null;
        data["expirationTime"] = this.expirationTime ? this.expirationTime.toJSON() : <any>null;
        data["lifetime"] = this.lifetime ? this.lifetime.toJSON() : <any>null;
        data["maxDevice"] = this.maxDevice ? this.maxDevice.toJSON() : <any>null;
        data["maxTraffic"] = this.maxTraffic ? this.maxTraffic.toJSON() : <any>null;
        data["isEnabled"] = this.isEnabled ? this.isEnabled.toJSON() : <any>null;
        data["adRequirement"] = this.adRequirement ? this.adRequirement.toJSON() : <any>null;
        data["description"] = this.description ? this.description.toJSON() : <any>null;
        return data;
    }
}

export interface IAccessTokenUpdateParams {
    accessTokenName?: PatchOfString | null;
    serverFarmId?: PatchOfGuid | null;
    expirationTime?: PatchOfNullableDateTime | null;
    lifetime?: PatchOfInteger | null;
    maxDevice?: PatchOfInteger | null;
    maxTraffic?: PatchOfLong | null;
    isEnabled?: PatchOfBoolean | null;
    adRequirement?: PatchOfAdRequirement | null;
    description?: PatchOfString | null;
}

export class PatchOfString implements IPatchOfString {
    value?: string | null;

    constructor(data?: IPatchOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): PatchOfString {
        data = typeof data === 'object' ? data : {};
        let result = new PatchOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }
}

export interface IPatchOfString {
    value?: string | null;
}

export class PatchOfGuid implements IPatchOfGuid {
    value!: string;

    constructor(data?: IPatchOfGuid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): PatchOfGuid {
        data = typeof data === 'object' ? data : {};
        let result = new PatchOfGuid();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }
}

export interface IPatchOfGuid {
    value: string;
}

export class PatchOfNullableDateTime implements IPatchOfNullableDateTime {
    value?: Date | null;

    constructor(data?: IPatchOfNullableDateTime) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] ? new Date(_data["value"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): PatchOfNullableDateTime {
        data = typeof data === 'object' ? data : {};
        let result = new PatchOfNullableDateTime();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? this.value.toISOString() : <any>null;
        return data;
    }
}

export interface IPatchOfNullableDateTime {
    value?: Date | null;
}

export class PatchOfInteger implements IPatchOfInteger {
    value!: number;

    constructor(data?: IPatchOfInteger) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): PatchOfInteger {
        data = typeof data === 'object' ? data : {};
        let result = new PatchOfInteger();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }
}

export interface IPatchOfInteger {
    value: number;
}

export class PatchOfLong implements IPatchOfLong {
    value!: number;

    constructor(data?: IPatchOfLong) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): PatchOfLong {
        data = typeof data === 'object' ? data : {};
        let result = new PatchOfLong();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }
}

export interface IPatchOfLong {
    value: number;
}

export class PatchOfBoolean implements IPatchOfBoolean {
    value!: boolean;

    constructor(data?: IPatchOfBoolean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): PatchOfBoolean {
        data = typeof data === 'object' ? data : {};
        let result = new PatchOfBoolean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }
}

export interface IPatchOfBoolean {
    value: boolean;
}

export class PatchOfAdRequirement implements IPatchOfAdRequirement {
    value!: AdRequirement;

    constructor(data?: IPatchOfAdRequirement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): PatchOfAdRequirement {
        data = typeof data === 'object' ? data : {};
        let result = new PatchOfAdRequirement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }
}

export interface IPatchOfAdRequirement {
    value: AdRequirement;
}

export class AccessTokenData implements IAccessTokenData {
    accessToken!: AccessToken;
    usage?: Usage | null;
    access?: Access | null;

    constructor(data?: IAccessTokenData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.accessToken = new AccessToken();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"] ? AccessToken.fromJS(_data["accessToken"]) : new AccessToken();
            this.usage = _data["usage"] ? Usage.fromJS(_data["usage"]) : <any>null;
            this.access = _data["access"] ? Access.fromJS(_data["access"]) : <any>null;
        }
    }

    static fromJS(data: any): AccessTokenData {
        data = typeof data === 'object' ? data : {};
        let result = new AccessTokenData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken ? this.accessToken.toJSON() : <any>null;
        data["usage"] = this.usage ? this.usage.toJSON() : <any>null;
        data["access"] = this.access ? this.access.toJSON() : <any>null;
        return data;
    }
}

export interface IAccessTokenData {
    accessToken: AccessToken;
    usage?: Usage | null;
    access?: Access | null;
}

export class Usage implements IUsage {
    sentTraffic!: number;
    receivedTraffic!: number;
    deviceCount?: number | null;
    serverCount?: number | null;
    sessionCount?: number | null;
    accessTokenCount?: number | null;
    countryCount?: number | null;

    constructor(data?: IUsage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sentTraffic = _data["sentTraffic"] !== undefined ? _data["sentTraffic"] : <any>null;
            this.receivedTraffic = _data["receivedTraffic"] !== undefined ? _data["receivedTraffic"] : <any>null;
            this.deviceCount = _data["deviceCount"] !== undefined ? _data["deviceCount"] : <any>null;
            this.serverCount = _data["serverCount"] !== undefined ? _data["serverCount"] : <any>null;
            this.sessionCount = _data["sessionCount"] !== undefined ? _data["sessionCount"] : <any>null;
            this.accessTokenCount = _data["accessTokenCount"] !== undefined ? _data["accessTokenCount"] : <any>null;
            this.countryCount = _data["countryCount"] !== undefined ? _data["countryCount"] : <any>null;
        }
    }

    static fromJS(data: any): Usage {
        data = typeof data === 'object' ? data : {};
        let result = new Usage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sentTraffic"] = this.sentTraffic !== undefined ? this.sentTraffic : <any>null;
        data["receivedTraffic"] = this.receivedTraffic !== undefined ? this.receivedTraffic : <any>null;
        data["deviceCount"] = this.deviceCount !== undefined ? this.deviceCount : <any>null;
        data["serverCount"] = this.serverCount !== undefined ? this.serverCount : <any>null;
        data["sessionCount"] = this.sessionCount !== undefined ? this.sessionCount : <any>null;
        data["accessTokenCount"] = this.accessTokenCount !== undefined ? this.accessTokenCount : <any>null;
        data["countryCount"] = this.countryCount !== undefined ? this.countryCount : <any>null;
        return data;
    }
}

export interface IUsage {
    sentTraffic: number;
    receivedTraffic: number;
    deviceCount?: number | null;
    serverCount?: number | null;
    sessionCount?: number | null;
    accessTokenCount?: number | null;
    countryCount?: number | null;
}

export class ListResultOfAccessTokenData implements IListResultOfAccessTokenData {
    totalCount?: number | null;
    items!: AccessTokenData[];

    constructor(data?: IListResultOfAccessTokenData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AccessTokenData.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
        }
    }

    static fromJS(data: any): ListResultOfAccessTokenData {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultOfAccessTokenData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultOfAccessTokenData {
    totalCount?: number | null;
    items: AccessTokenData[];
}

export class DeviceData implements IDeviceData {
    device!: Device;
    usage?: TrafficUsage | null;

    constructor(data?: IDeviceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.device = new Device();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.device = _data["device"] ? Device.fromJS(_data["device"]) : new Device();
            this.usage = _data["usage"] ? TrafficUsage.fromJS(_data["usage"]) : <any>null;
        }
    }

    static fromJS(data: any): DeviceData {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["device"] = this.device ? this.device.toJSON() : <any>null;
        data["usage"] = this.usage ? this.usage.toJSON() : <any>null;
        return data;
    }
}

export interface IDeviceData {
    device: Device;
    usage?: TrafficUsage | null;
}

export class TrafficUsage implements ITrafficUsage {
    sentTraffic!: number;
    receivedTraffic!: number;
    lastUsedTime!: Date;

    constructor(data?: ITrafficUsage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sentTraffic = _data["sentTraffic"] !== undefined ? _data["sentTraffic"] : <any>null;
            this.receivedTraffic = _data["receivedTraffic"] !== undefined ? _data["receivedTraffic"] : <any>null;
            this.lastUsedTime = _data["lastUsedTime"] ? new Date(_data["lastUsedTime"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): TrafficUsage {
        data = typeof data === 'object' ? data : {};
        let result = new TrafficUsage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sentTraffic"] = this.sentTraffic !== undefined ? this.sentTraffic : <any>null;
        data["receivedTraffic"] = this.receivedTraffic !== undefined ? this.receivedTraffic : <any>null;
        data["lastUsedTime"] = this.lastUsedTime ? this.lastUsedTime.toISOString() : <any>null;
        return data;
    }
}

export interface ITrafficUsage {
    sentTraffic: number;
    receivedTraffic: number;
    lastUsedTime: Date;
}

export class DeviceUpdateParams implements IDeviceUpdateParams {
    isLocked?: PatchOfBoolean | null;

    constructor(data?: IDeviceUpdateParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isLocked = _data["isLocked"] ? PatchOfBoolean.fromJS(_data["isLocked"]) : <any>null;
        }
    }

    static fromJS(data: any): DeviceUpdateParams {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceUpdateParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLocked"] = this.isLocked ? this.isLocked.toJSON() : <any>null;
        return data;
    }
}

export interface IDeviceUpdateParams {
    isLocked?: PatchOfBoolean | null;
}

export class FarmTokenRepo implements IFarmTokenRepo {
    farmTokenRepoId!: string;
    farmTokenRepoName!: string;
    publishUrl!: string;
    repoSettings?: FarmTokenRepoSettings | null;
    isUpToDate?: boolean | null;
    error?: string | null;

    constructor(data?: IFarmTokenRepo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.farmTokenRepoId = _data["farmTokenRepoId"] !== undefined ? _data["farmTokenRepoId"] : <any>null;
            this.farmTokenRepoName = _data["farmTokenRepoName"] !== undefined ? _data["farmTokenRepoName"] : <any>null;
            this.publishUrl = _data["publishUrl"] !== undefined ? _data["publishUrl"] : <any>null;
            this.repoSettings = _data["repoSettings"] ? FarmTokenRepoSettings.fromJS(_data["repoSettings"]) : <any>null;
            this.isUpToDate = _data["isUpToDate"] !== undefined ? _data["isUpToDate"] : <any>null;
            this.error = _data["error"] !== undefined ? _data["error"] : <any>null;
        }
    }

    static fromJS(data: any): FarmTokenRepo {
        data = typeof data === 'object' ? data : {};
        let result = new FarmTokenRepo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["farmTokenRepoId"] = this.farmTokenRepoId !== undefined ? this.farmTokenRepoId : <any>null;
        data["farmTokenRepoName"] = this.farmTokenRepoName !== undefined ? this.farmTokenRepoName : <any>null;
        data["publishUrl"] = this.publishUrl !== undefined ? this.publishUrl : <any>null;
        data["repoSettings"] = this.repoSettings ? this.repoSettings.toJSON() : <any>null;
        data["isUpToDate"] = this.isUpToDate !== undefined ? this.isUpToDate : <any>null;
        data["error"] = this.error !== undefined ? this.error : <any>null;
        return data;
    }
}

export interface IFarmTokenRepo {
    farmTokenRepoId: string;
    farmTokenRepoName: string;
    publishUrl: string;
    repoSettings?: FarmTokenRepoSettings | null;
    isUpToDate?: boolean | null;
    error?: string | null;
}

export class FarmTokenRepoSettings implements IFarmTokenRepoSettings {
    fileUrl!: string;
    uploadMethod!: UploadMethod;
    accessToken?: string | null;
    headers!: { [key: string]: string; };
    formData!: { [key: string]: string; };
    body?: string | null;

    constructor(data?: IFarmTokenRepoSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.headers = {};
            this.formData = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileUrl = _data["fileUrl"] !== undefined ? _data["fileUrl"] : <any>null;
            this.uploadMethod = _data["uploadMethod"] !== undefined ? _data["uploadMethod"] : <any>null;
            this.accessToken = _data["accessToken"] !== undefined ? _data["accessToken"] : <any>null;
            if (_data["headers"]) {
                this.headers = {} as any;
                for (let key in _data["headers"]) {
                    if (_data["headers"].hasOwnProperty(key))
                        (<any>this.headers)![key] = _data["headers"][key] !== undefined ? _data["headers"][key] : <any>null;
                }
            }
            else {
                this.headers = <any>null;
            }
            if (_data["formData"]) {
                this.formData = {} as any;
                for (let key in _data["formData"]) {
                    if (_data["formData"].hasOwnProperty(key))
                        (<any>this.formData)![key] = _data["formData"][key] !== undefined ? _data["formData"][key] : <any>null;
                }
            }
            else {
                this.formData = <any>null;
            }
            this.body = _data["body"] !== undefined ? _data["body"] : <any>null;
        }
    }

    static fromJS(data: any): FarmTokenRepoSettings {
        data = typeof data === 'object' ? data : {};
        let result = new FarmTokenRepoSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileUrl"] = this.fileUrl !== undefined ? this.fileUrl : <any>null;
        data["uploadMethod"] = this.uploadMethod !== undefined ? this.uploadMethod : <any>null;
        data["accessToken"] = this.accessToken !== undefined ? this.accessToken : <any>null;
        if (this.headers) {
            data["headers"] = {};
            for (let key in this.headers) {
                if (this.headers.hasOwnProperty(key))
                    (<any>data["headers"])[key] = this.headers[key] !== undefined ? this.headers[key] : <any>null;
            }
        }
        if (this.formData) {
            data["formData"] = {};
            for (let key in this.formData) {
                if (this.formData.hasOwnProperty(key))
                    (<any>data["formData"])[key] = this.formData[key] !== undefined ? this.formData[key] : <any>null;
            }
        }
        data["body"] = this.body !== undefined ? this.body : <any>null;
        return data;
    }
}

export interface IFarmTokenRepoSettings {
    fileUrl: string;
    uploadMethod: UploadMethod;
    accessToken?: string | null;
    headers: { [key: string]: string; };
    formData: { [key: string]: string; };
    body?: string | null;
}

export enum UploadMethod {
    None = "None",
    Post = "Post",
    Put = "Put",
    PutPost = "PutPost",
}

export class FarmTokenRepoCreateParams implements IFarmTokenRepoCreateParams {
    repoName!: string;
    publishUrl!: string;
    repoSettings?: FarmTokenRepoSettings | null;

    constructor(data?: IFarmTokenRepoCreateParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.repoName = _data["repoName"] !== undefined ? _data["repoName"] : <any>null;
            this.publishUrl = _data["publishUrl"] !== undefined ? _data["publishUrl"] : <any>null;
            this.repoSettings = _data["repoSettings"] ? FarmTokenRepoSettings.fromJS(_data["repoSettings"]) : <any>null;
        }
    }

    static fromJS(data: any): FarmTokenRepoCreateParams {
        data = typeof data === 'object' ? data : {};
        let result = new FarmTokenRepoCreateParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["repoName"] = this.repoName !== undefined ? this.repoName : <any>null;
        data["publishUrl"] = this.publishUrl !== undefined ? this.publishUrl : <any>null;
        data["repoSettings"] = this.repoSettings ? this.repoSettings.toJSON() : <any>null;
        return data;
    }
}

export interface IFarmTokenRepoCreateParams {
    repoName: string;
    publishUrl: string;
    repoSettings?: FarmTokenRepoSettings | null;
}

export class FarmTokenRepoSummary implements IFarmTokenRepoSummary {
    upToDateRepoNames!: string[];
    outdatedRepoNames!: string[];
    total!: number;

    constructor(data?: IFarmTokenRepoSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.upToDateRepoNames = [];
            this.outdatedRepoNames = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["upToDateRepoNames"])) {
                this.upToDateRepoNames = [] as any;
                for (let item of _data["upToDateRepoNames"])
                    this.upToDateRepoNames!.push(item);
            }
            else {
                this.upToDateRepoNames = <any>null;
            }
            if (Array.isArray(_data["outdatedRepoNames"])) {
                this.outdatedRepoNames = [] as any;
                for (let item of _data["outdatedRepoNames"])
                    this.outdatedRepoNames!.push(item);
            }
            else {
                this.outdatedRepoNames = <any>null;
            }
            this.total = _data["total"] !== undefined ? _data["total"] : <any>null;
        }
    }

    static fromJS(data: any): FarmTokenRepoSummary {
        data = typeof data === 'object' ? data : {};
        let result = new FarmTokenRepoSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.upToDateRepoNames)) {
            data["upToDateRepoNames"] = [];
            for (let item of this.upToDateRepoNames)
                data["upToDateRepoNames"].push(item);
        }
        if (Array.isArray(this.outdatedRepoNames)) {
            data["outdatedRepoNames"] = [];
            for (let item of this.outdatedRepoNames)
                data["outdatedRepoNames"].push(item);
        }
        data["total"] = this.total !== undefined ? this.total : <any>null;
        return data;
    }
}

export interface IFarmTokenRepoSummary {
    upToDateRepoNames: string[];
    outdatedRepoNames: string[];
    total: number;
}

export class FarmTokenRepoUpdateParams implements IFarmTokenRepoUpdateParams {
    repoName?: PatchOfString | null;
    publishUrl?: PatchOfUri | null;
    repoSettings?: PatchOfFarmTokenRepoSettings | null;

    constructor(data?: IFarmTokenRepoUpdateParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.repoName = _data["repoName"] ? PatchOfString.fromJS(_data["repoName"]) : <any>null;
            this.publishUrl = _data["publishUrl"] ? PatchOfUri.fromJS(_data["publishUrl"]) : <any>null;
            this.repoSettings = _data["repoSettings"] ? PatchOfFarmTokenRepoSettings.fromJS(_data["repoSettings"]) : <any>null;
        }
    }

    static fromJS(data: any): FarmTokenRepoUpdateParams {
        data = typeof data === 'object' ? data : {};
        let result = new FarmTokenRepoUpdateParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["repoName"] = this.repoName ? this.repoName.toJSON() : <any>null;
        data["publishUrl"] = this.publishUrl ? this.publishUrl.toJSON() : <any>null;
        data["repoSettings"] = this.repoSettings ? this.repoSettings.toJSON() : <any>null;
        return data;
    }
}

export interface IFarmTokenRepoUpdateParams {
    repoName?: PatchOfString | null;
    publishUrl?: PatchOfUri | null;
    repoSettings?: PatchOfFarmTokenRepoSettings | null;
}

export class PatchOfUri implements IPatchOfUri {
    value?: string | null;

    constructor(data?: IPatchOfUri) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): PatchOfUri {
        data = typeof data === 'object' ? data : {};
        let result = new PatchOfUri();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }
}

export interface IPatchOfUri {
    value?: string | null;
}

export class PatchOfFarmTokenRepoSettings implements IPatchOfFarmTokenRepoSettings {
    value?: FarmTokenRepoSettings | null;

    constructor(data?: IPatchOfFarmTokenRepoSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] ? FarmTokenRepoSettings.fromJS(_data["value"]) : <any>null;
        }
    }

    static fromJS(data: any): PatchOfFarmTokenRepoSettings {
        data = typeof data === 'object' ? data : {};
        let result = new PatchOfFarmTokenRepoSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? this.value.toJSON() : <any>null;
        return data;
    }
}

export interface IPatchOfFarmTokenRepoSettings {
    value?: FarmTokenRepoSettings | null;
}

export class HostIp implements IHostIp {
    ipAddress!: string;
    providerId!: string;
    providerName!: string;
    createdTime!: Date;
    autoReleaseTime?: Date | null;
    releaseRequestTime?: Date | null;
    serverId?: string | null;
    existsInProvider!: boolean;
    providerDescription?: string | null;
    serverName?: string | null;
    serverLocation?: Location | null;
    serverFarmId?: string | null;
    serverFarmName?: string | null;
    status!: HostIpStatus;

    constructor(data?: IHostIp) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ipAddress = _data["ipAddress"] !== undefined ? _data["ipAddress"] : <any>null;
            this.providerId = _data["providerId"] !== undefined ? _data["providerId"] : <any>null;
            this.providerName = _data["providerName"] !== undefined ? _data["providerName"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.autoReleaseTime = _data["autoReleaseTime"] ? new Date(_data["autoReleaseTime"].toString()) : <any>null;
            this.releaseRequestTime = _data["releaseRequestTime"] ? new Date(_data["releaseRequestTime"].toString()) : <any>null;
            this.serverId = _data["serverId"] !== undefined ? _data["serverId"] : <any>null;
            this.existsInProvider = _data["existsInProvider"] !== undefined ? _data["existsInProvider"] : <any>null;
            this.providerDescription = _data["providerDescription"] !== undefined ? _data["providerDescription"] : <any>null;
            this.serverName = _data["serverName"] !== undefined ? _data["serverName"] : <any>null;
            this.serverLocation = _data["serverLocation"] ? Location.fromJS(_data["serverLocation"]) : <any>null;
            this.serverFarmId = _data["serverFarmId"] !== undefined ? _data["serverFarmId"] : <any>null;
            this.serverFarmName = _data["serverFarmName"] !== undefined ? _data["serverFarmName"] : <any>null;
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
        }
    }

    static fromJS(data: any): HostIp {
        data = typeof data === 'object' ? data : {};
        let result = new HostIp();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ipAddress"] = this.ipAddress !== undefined ? this.ipAddress : <any>null;
        data["providerId"] = this.providerId !== undefined ? this.providerId : <any>null;
        data["providerName"] = this.providerName !== undefined ? this.providerName : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["autoReleaseTime"] = this.autoReleaseTime ? this.autoReleaseTime.toISOString() : <any>null;
        data["releaseRequestTime"] = this.releaseRequestTime ? this.releaseRequestTime.toISOString() : <any>null;
        data["serverId"] = this.serverId !== undefined ? this.serverId : <any>null;
        data["existsInProvider"] = this.existsInProvider !== undefined ? this.existsInProvider : <any>null;
        data["providerDescription"] = this.providerDescription !== undefined ? this.providerDescription : <any>null;
        data["serverName"] = this.serverName !== undefined ? this.serverName : <any>null;
        data["serverLocation"] = this.serverLocation ? this.serverLocation.toJSON() : <any>null;
        data["serverFarmId"] = this.serverFarmId !== undefined ? this.serverFarmId : <any>null;
        data["serverFarmName"] = this.serverFarmName !== undefined ? this.serverFarmName : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        return data;
    }
}

export interface IHostIp {
    ipAddress: string;
    providerId: string;
    providerName: string;
    createdTime: Date;
    autoReleaseTime?: Date | null;
    releaseRequestTime?: Date | null;
    serverId?: string | null;
    existsInProvider: boolean;
    providerDescription?: string | null;
    serverName?: string | null;
    serverLocation?: Location | null;
    serverFarmId?: string | null;
    serverFarmName?: string | null;
    status: HostIpStatus;
}

export class Location implements ILocation {
    countryName!: string;
    countryCode!: string;
    regionName?: string | null;
    regionCode?: string | null;
    cityName?: string | null;
    cityCode?: string | null;
    displayName!: string;

    constructor(data?: ILocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.countryName = _data["countryName"] !== undefined ? _data["countryName"] : <any>null;
            this.countryCode = _data["countryCode"] !== undefined ? _data["countryCode"] : <any>null;
            this.regionName = _data["regionName"] !== undefined ? _data["regionName"] : <any>null;
            this.regionCode = _data["regionCode"] !== undefined ? _data["regionCode"] : <any>null;
            this.cityName = _data["cityName"] !== undefined ? _data["cityName"] : <any>null;
            this.cityCode = _data["cityCode"] !== undefined ? _data["cityCode"] : <any>null;
            this.displayName = _data["displayName"] !== undefined ? _data["displayName"] : <any>null;
        }
    }

    static fromJS(data: any): Location {
        data = typeof data === 'object' ? data : {};
        let result = new Location();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryName"] = this.countryName !== undefined ? this.countryName : <any>null;
        data["countryCode"] = this.countryCode !== undefined ? this.countryCode : <any>null;
        data["regionName"] = this.regionName !== undefined ? this.regionName : <any>null;
        data["regionCode"] = this.regionCode !== undefined ? this.regionCode : <any>null;
        data["cityName"] = this.cityName !== undefined ? this.cityName : <any>null;
        data["cityCode"] = this.cityCode !== undefined ? this.cityCode : <any>null;
        data["displayName"] = this.displayName !== undefined ? this.displayName : <any>null;
        return data;
    }
}

export interface ILocation {
    countryName: string;
    countryCode: string;
    regionName?: string | null;
    regionCode?: string | null;
    cityName?: string | null;
    cityCode?: string | null;
    displayName: string;
}

export enum HostIpStatus {
    InUse = "InUse",
    NotInUse = "NotInUse",
    NotInProvider = "NotInProvider",
    Releasing = "Releasing",
}

export class HostIpUpdateParams implements IHostIpUpdateParams {
    autoReleaseTime?: PatchOfNullableDateTime | null;

    constructor(data?: IHostIpUpdateParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.autoReleaseTime = _data["autoReleaseTime"] ? PatchOfNullableDateTime.fromJS(_data["autoReleaseTime"]) : <any>null;
        }
    }

    static fromJS(data: any): HostIpUpdateParams {
        data = typeof data === 'object' ? data : {};
        let result = new HostIpUpdateParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["autoReleaseTime"] = this.autoReleaseTime ? this.autoReleaseTime.toJSON() : <any>null;
        return data;
    }
}

export interface IHostIpUpdateParams {
    autoReleaseTime?: PatchOfNullableDateTime | null;
}

export class HostOrder implements IHostOrder {
    orderId!: string;
    createdTime!: Date;
    orderType!: HostOrderType;
    status!: HostOrderStatus;
    providerOrderId!: string;
    hostProviderId!: string;
    hostProviderName!: string;
    errorMessage?: string | null;
    completedTime?: Date | null;
    newIpOrderIpAddress?: string | null;
    serverId?: string | null;
    serverName?: string | null;
    serverLocation?: Location | null;
    serverFarmId?: string | null;
    serverFarmName?: string | null;

    constructor(data?: IHostOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"] !== undefined ? _data["orderId"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.orderType = _data["orderType"] !== undefined ? _data["orderType"] : <any>null;
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.providerOrderId = _data["providerOrderId"] !== undefined ? _data["providerOrderId"] : <any>null;
            this.hostProviderId = _data["hostProviderId"] !== undefined ? _data["hostProviderId"] : <any>null;
            this.hostProviderName = _data["hostProviderName"] !== undefined ? _data["hostProviderName"] : <any>null;
            this.errorMessage = _data["errorMessage"] !== undefined ? _data["errorMessage"] : <any>null;
            this.completedTime = _data["completedTime"] ? new Date(_data["completedTime"].toString()) : <any>null;
            this.newIpOrderIpAddress = _data["newIpOrderIpAddress"] !== undefined ? _data["newIpOrderIpAddress"] : <any>null;
            this.serverId = _data["serverId"] !== undefined ? _data["serverId"] : <any>null;
            this.serverName = _data["serverName"] !== undefined ? _data["serverName"] : <any>null;
            this.serverLocation = _data["serverLocation"] ? Location.fromJS(_data["serverLocation"]) : <any>null;
            this.serverFarmId = _data["serverFarmId"] !== undefined ? _data["serverFarmId"] : <any>null;
            this.serverFarmName = _data["serverFarmName"] !== undefined ? _data["serverFarmName"] : <any>null;
        }
    }

    static fromJS(data: any): HostOrder {
        data = typeof data === 'object' ? data : {};
        let result = new HostOrder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId !== undefined ? this.orderId : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["orderType"] = this.orderType !== undefined ? this.orderType : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["providerOrderId"] = this.providerOrderId !== undefined ? this.providerOrderId : <any>null;
        data["hostProviderId"] = this.hostProviderId !== undefined ? this.hostProviderId : <any>null;
        data["hostProviderName"] = this.hostProviderName !== undefined ? this.hostProviderName : <any>null;
        data["errorMessage"] = this.errorMessage !== undefined ? this.errorMessage : <any>null;
        data["completedTime"] = this.completedTime ? this.completedTime.toISOString() : <any>null;
        data["newIpOrderIpAddress"] = this.newIpOrderIpAddress !== undefined ? this.newIpOrderIpAddress : <any>null;
        data["serverId"] = this.serverId !== undefined ? this.serverId : <any>null;
        data["serverName"] = this.serverName !== undefined ? this.serverName : <any>null;
        data["serverLocation"] = this.serverLocation ? this.serverLocation.toJSON() : <any>null;
        data["serverFarmId"] = this.serverFarmId !== undefined ? this.serverFarmId : <any>null;
        data["serverFarmName"] = this.serverFarmName !== undefined ? this.serverFarmName : <any>null;
        return data;
    }
}

export interface IHostOrder {
    orderId: string;
    createdTime: Date;
    orderType: HostOrderType;
    status: HostOrderStatus;
    providerOrderId: string;
    hostProviderId: string;
    hostProviderName: string;
    errorMessage?: string | null;
    completedTime?: Date | null;
    newIpOrderIpAddress?: string | null;
    serverId?: string | null;
    serverName?: string | null;
    serverLocation?: Location | null;
    serverFarmId?: string | null;
    serverFarmName?: string | null;
}

export enum HostOrderType {
    NewIp = "NewIp",
}

export enum HostOrderStatus {
    Pending = "Pending",
    Completed = "Completed",
    Failed = "Failed",
}

export class HostOrderNewIp implements IHostOrderNewIp {
    serverId!: string;
    oldIpAddressReleaseTime?: Date | null;
    oldIpAddress?: string | null;

    constructor(data?: IHostOrderNewIp) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serverId = _data["serverId"] !== undefined ? _data["serverId"] : <any>null;
            this.oldIpAddressReleaseTime = _data["oldIpAddressReleaseTime"] ? new Date(_data["oldIpAddressReleaseTime"].toString()) : <any>null;
            this.oldIpAddress = _data["oldIpAddress"] !== undefined ? _data["oldIpAddress"] : <any>null;
        }
    }

    static fromJS(data: any): HostOrderNewIp {
        data = typeof data === 'object' ? data : {};
        let result = new HostOrderNewIp();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverId"] = this.serverId !== undefined ? this.serverId : <any>null;
        data["oldIpAddressReleaseTime"] = this.oldIpAddressReleaseTime ? this.oldIpAddressReleaseTime.toISOString() : <any>null;
        data["oldIpAddress"] = this.oldIpAddress !== undefined ? this.oldIpAddress : <any>null;
        return data;
    }
}

export interface IHostOrderNewIp {
    serverId: string;
    oldIpAddressReleaseTime?: Date | null;
    oldIpAddress?: string | null;
}

export class IpLock implements IIpLock {
    ipAddress!: string;
    lockedTime?: Date | null;
    description?: string | null;

    constructor(data?: IIpLock) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ipAddress = _data["ipAddress"] !== undefined ? _data["ipAddress"] : <any>null;
            this.lockedTime = _data["lockedTime"] ? new Date(_data["lockedTime"].toString()) : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
        }
    }

    static fromJS(data: any): IpLock {
        data = typeof data === 'object' ? data : {};
        let result = new IpLock();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ipAddress"] = this.ipAddress !== undefined ? this.ipAddress : <any>null;
        data["lockedTime"] = this.lockedTime ? this.lockedTime.toISOString() : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data;
    }
}

export interface IIpLock {
    ipAddress: string;
    lockedTime?: Date | null;
    description?: string | null;
}

export class IpLockCreateParams implements IIpLockCreateParams {
    ipAddress!: string;
    isLocked!: boolean;
    description?: string | null;

    constructor(data?: IIpLockCreateParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ipAddress = _data["ipAddress"] !== undefined ? _data["ipAddress"] : <any>null;
            this.isLocked = _data["isLocked"] !== undefined ? _data["isLocked"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
        }
    }

    static fromJS(data: any): IpLockCreateParams {
        data = typeof data === 'object' ? data : {};
        let result = new IpLockCreateParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ipAddress"] = this.ipAddress !== undefined ? this.ipAddress : <any>null;
        data["isLocked"] = this.isLocked !== undefined ? this.isLocked : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data;
    }
}

export interface IIpLockCreateParams {
    ipAddress: string;
    isLocked: boolean;
    description?: string | null;
}

export class IpLockUpdateParams implements IIpLockUpdateParams {
    isLocked?: PatchOfBoolean | null;
    description?: PatchOfString | null;

    constructor(data?: IIpLockUpdateParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isLocked = _data["isLocked"] ? PatchOfBoolean.fromJS(_data["isLocked"]) : <any>null;
            this.description = _data["description"] ? PatchOfString.fromJS(_data["description"]) : <any>null;
        }
    }

    static fromJS(data: any): IpLockUpdateParams {
        data = typeof data === 'object' ? data : {};
        let result = new IpLockUpdateParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isLocked"] = this.isLocked ? this.isLocked.toJSON() : <any>null;
        data["description"] = this.description ? this.description.toJSON() : <any>null;
        return data;
    }
}

export interface IIpLockUpdateParams {
    isLocked?: PatchOfBoolean | null;
    description?: PatchOfString | null;
}

export class Project implements IProject {
    projectId!: string;
    projectName?: string | null;
    createdTime!: Date;
    subscriptionType!: SubscriptionType;
    gaMeasurementId?: string | null;
    gaApiSecret?: string | null;
    adRewardSecret!: string;
    adRewardUrl!: string;
    hastHostProvider!: boolean;

    constructor(data?: IProject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectId = _data["projectId"] !== undefined ? _data["projectId"] : <any>null;
            this.projectName = _data["projectName"] !== undefined ? _data["projectName"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.subscriptionType = _data["subscriptionType"] !== undefined ? _data["subscriptionType"] : <any>null;
            this.gaMeasurementId = _data["gaMeasurementId"] !== undefined ? _data["gaMeasurementId"] : <any>null;
            this.gaApiSecret = _data["gaApiSecret"] !== undefined ? _data["gaApiSecret"] : <any>null;
            this.adRewardSecret = _data["adRewardSecret"] !== undefined ? _data["adRewardSecret"] : <any>null;
            this.adRewardUrl = _data["adRewardUrl"] !== undefined ? _data["adRewardUrl"] : <any>null;
            this.hastHostProvider = _data["hastHostProvider"] !== undefined ? _data["hastHostProvider"] : <any>null;
        }
    }

    static fromJS(data: any): Project {
        data = typeof data === 'object' ? data : {};
        let result = new Project();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectId"] = this.projectId !== undefined ? this.projectId : <any>null;
        data["projectName"] = this.projectName !== undefined ? this.projectName : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["subscriptionType"] = this.subscriptionType !== undefined ? this.subscriptionType : <any>null;
        data["gaMeasurementId"] = this.gaMeasurementId !== undefined ? this.gaMeasurementId : <any>null;
        data["gaApiSecret"] = this.gaApiSecret !== undefined ? this.gaApiSecret : <any>null;
        data["adRewardSecret"] = this.adRewardSecret !== undefined ? this.adRewardSecret : <any>null;
        data["adRewardUrl"] = this.adRewardUrl !== undefined ? this.adRewardUrl : <any>null;
        data["hastHostProvider"] = this.hastHostProvider !== undefined ? this.hastHostProvider : <any>null;
        return data;
    }
}

export interface IProject {
    projectId: string;
    projectName?: string | null;
    createdTime: Date;
    subscriptionType: SubscriptionType;
    gaMeasurementId?: string | null;
    gaApiSecret?: string | null;
    adRewardSecret: string;
    adRewardUrl: string;
    hastHostProvider: boolean;
}

export enum SubscriptionType {
    Free = "Free",
    Unlimited = "Unlimited",
}

export class ProjectUpdateParams implements IProjectUpdateParams {
    projectName?: PatchOfString | null;
    gaMeasurementId?: PatchOfString | null;
    gaApiSecret?: PatchOfString | null;
    adRewardSecret?: PatchOfString | null;

    constructor(data?: IProjectUpdateParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectName = _data["projectName"] ? PatchOfString.fromJS(_data["projectName"]) : <any>null;
            this.gaMeasurementId = _data["gaMeasurementId"] ? PatchOfString.fromJS(_data["gaMeasurementId"]) : <any>null;
            this.gaApiSecret = _data["gaApiSecret"] ? PatchOfString.fromJS(_data["gaApiSecret"]) : <any>null;
            this.adRewardSecret = _data["adRewardSecret"] ? PatchOfString.fromJS(_data["adRewardSecret"]) : <any>null;
        }
    }

    static fromJS(data: any): ProjectUpdateParams {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectUpdateParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectName"] = this.projectName ? this.projectName.toJSON() : <any>null;
        data["gaMeasurementId"] = this.gaMeasurementId ? this.gaMeasurementId.toJSON() : <any>null;
        data["gaApiSecret"] = this.gaApiSecret ? this.gaApiSecret.toJSON() : <any>null;
        data["adRewardSecret"] = this.adRewardSecret ? this.adRewardSecret.toJSON() : <any>null;
        return data;
    }
}

export interface IProjectUpdateParams {
    projectName?: PatchOfString | null;
    gaMeasurementId?: PatchOfString | null;
    gaApiSecret?: PatchOfString | null;
    adRewardSecret?: PatchOfString | null;
}

export class ServerStatusHistory implements IServerStatusHistory {
    time!: Date;
    sessionCount!: number;
    tunnelTransferSpeed!: number;
    serverCount!: number;
    cpuUsage!: number;
    availableMemory!: number;

    constructor(data?: IServerStatusHistory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.time = _data["time"] ? new Date(_data["time"].toString()) : <any>null;
            this.sessionCount = _data["sessionCount"] !== undefined ? _data["sessionCount"] : <any>null;
            this.tunnelTransferSpeed = _data["tunnelTransferSpeed"] !== undefined ? _data["tunnelTransferSpeed"] : <any>null;
            this.serverCount = _data["serverCount"] !== undefined ? _data["serverCount"] : <any>null;
            this.cpuUsage = _data["cpuUsage"] !== undefined ? _data["cpuUsage"] : <any>null;
            this.availableMemory = _data["availableMemory"] !== undefined ? _data["availableMemory"] : <any>null;
        }
    }

    static fromJS(data: any): ServerStatusHistory {
        data = typeof data === 'object' ? data : {};
        let result = new ServerStatusHistory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["time"] = this.time ? this.time.toISOString() : <any>null;
        data["sessionCount"] = this.sessionCount !== undefined ? this.sessionCount : <any>null;
        data["tunnelTransferSpeed"] = this.tunnelTransferSpeed !== undefined ? this.tunnelTransferSpeed : <any>null;
        data["serverCount"] = this.serverCount !== undefined ? this.serverCount : <any>null;
        data["cpuUsage"] = this.cpuUsage !== undefined ? this.cpuUsage : <any>null;
        data["availableMemory"] = this.availableMemory !== undefined ? this.availableMemory : <any>null;
        return data;
    }
}

export interface IServerStatusHistory {
    time: Date;
    sessionCount: number;
    tunnelTransferSpeed: number;
    serverCount: number;
    cpuUsage: number;
    availableMemory: number;
}

export class ServerFarmData implements IServerFarmData {
    serverFarm!: ServerFarm;
    certificates?: Certificate[] | null;
    accessPoints!: AccessPointView[];
    summary?: ServerFarmSummary | null;
    farmTokenRepoNames?: string[] | null;

    constructor(data?: IServerFarmData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.serverFarm = new ServerFarm();
            this.accessPoints = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serverFarm = _data["serverFarm"] ? ServerFarm.fromJS(_data["serverFarm"]) : new ServerFarm();
            if (Array.isArray(_data["certificates"])) {
                this.certificates = [] as any;
                for (let item of _data["certificates"])
                    this.certificates!.push(Certificate.fromJS(item));
            }
            else {
                this.certificates = <any>null;
            }
            if (Array.isArray(_data["accessPoints"])) {
                this.accessPoints = [] as any;
                for (let item of _data["accessPoints"])
                    this.accessPoints!.push(AccessPointView.fromJS(item));
            }
            else {
                this.accessPoints = <any>null;
            }
            this.summary = _data["summary"] ? ServerFarmSummary.fromJS(_data["summary"]) : <any>null;
            if (Array.isArray(_data["farmTokenRepoNames"])) {
                this.farmTokenRepoNames = [] as any;
                for (let item of _data["farmTokenRepoNames"])
                    this.farmTokenRepoNames!.push(item);
            }
            else {
                this.farmTokenRepoNames = <any>null;
            }
        }
    }

    static fromJS(data: any): ServerFarmData {
        data = typeof data === 'object' ? data : {};
        let result = new ServerFarmData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverFarm"] = this.serverFarm ? this.serverFarm.toJSON() : <any>null;
        if (Array.isArray(this.certificates)) {
            data["certificates"] = [];
            for (let item of this.certificates)
                data["certificates"].push(item.toJSON());
        }
        if (Array.isArray(this.accessPoints)) {
            data["accessPoints"] = [];
            for (let item of this.accessPoints)
                data["accessPoints"].push(item.toJSON());
        }
        data["summary"] = this.summary ? this.summary.toJSON() : <any>null;
        if (Array.isArray(this.farmTokenRepoNames)) {
            data["farmTokenRepoNames"] = [];
            for (let item of this.farmTokenRepoNames)
                data["farmTokenRepoNames"].push(item);
        }
        return data;
    }
}

export interface IServerFarmData {
    serverFarm: ServerFarm;
    certificates?: Certificate[] | null;
    accessPoints: AccessPointView[];
    summary?: ServerFarmSummary | null;
    farmTokenRepoNames?: string[] | null;
}

export class ServerFarm implements IServerFarm {
    serverFarmId!: string;
    serverProfileId!: string;
    serverFarmName!: string;
    serverProfileName!: string;
    useHostName!: boolean;
    tokenError?: string | null;
    secret!: string;
    createdTime!: Date;
    pushTokenToClient!: boolean;
    maxCertificateCount!: number;
    certificate?: Certificate | null;

    constructor(data?: IServerFarm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serverFarmId = _data["serverFarmId"] !== undefined ? _data["serverFarmId"] : <any>null;
            this.serverProfileId = _data["serverProfileId"] !== undefined ? _data["serverProfileId"] : <any>null;
            this.serverFarmName = _data["serverFarmName"] !== undefined ? _data["serverFarmName"] : <any>null;
            this.serverProfileName = _data["serverProfileName"] !== undefined ? _data["serverProfileName"] : <any>null;
            this.useHostName = _data["useHostName"] !== undefined ? _data["useHostName"] : <any>null;
            this.tokenError = _data["tokenError"] !== undefined ? _data["tokenError"] : <any>null;
            this.secret = _data["secret"] !== undefined ? _data["secret"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.pushTokenToClient = _data["pushTokenToClient"] !== undefined ? _data["pushTokenToClient"] : <any>null;
            this.maxCertificateCount = _data["maxCertificateCount"] !== undefined ? _data["maxCertificateCount"] : <any>null;
            this.certificate = _data["certificate"] ? Certificate.fromJS(_data["certificate"]) : <any>null;
        }
    }

    static fromJS(data: any): ServerFarm {
        data = typeof data === 'object' ? data : {};
        let result = new ServerFarm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverFarmId"] = this.serverFarmId !== undefined ? this.serverFarmId : <any>null;
        data["serverProfileId"] = this.serverProfileId !== undefined ? this.serverProfileId : <any>null;
        data["serverFarmName"] = this.serverFarmName !== undefined ? this.serverFarmName : <any>null;
        data["serverProfileName"] = this.serverProfileName !== undefined ? this.serverProfileName : <any>null;
        data["useHostName"] = this.useHostName !== undefined ? this.useHostName : <any>null;
        data["tokenError"] = this.tokenError !== undefined ? this.tokenError : <any>null;
        data["secret"] = this.secret !== undefined ? this.secret : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["pushTokenToClient"] = this.pushTokenToClient !== undefined ? this.pushTokenToClient : <any>null;
        data["maxCertificateCount"] = this.maxCertificateCount !== undefined ? this.maxCertificateCount : <any>null;
        data["certificate"] = this.certificate ? this.certificate.toJSON() : <any>null;
        return data;
    }
}

export interface IServerFarm {
    serverFarmId: string;
    serverProfileId: string;
    serverFarmName: string;
    serverProfileName: string;
    useHostName: boolean;
    tokenError?: string | null;
    secret: string;
    createdTime: Date;
    pushTokenToClient: boolean;
    maxCertificateCount: number;
    certificate?: Certificate | null;
}

export class Certificate implements ICertificate {
    certificateId!: string;
    isInToken!: boolean;
    commonName!: string;
    issueTime!: Date;
    expirationTime!: Date;
    createdTime!: Date;
    thumbprint!: string;
    isValidated!: boolean;
    autoValidate!: boolean;
    validateCount!: number;
    validateInprogress!: boolean;
    validateErrorCount!: number;
    validateError?: string | null;
    validateErrorTime?: Date | null;

    constructor(data?: ICertificate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.certificateId = _data["certificateId"] !== undefined ? _data["certificateId"] : <any>null;
            this.isInToken = _data["isInToken"] !== undefined ? _data["isInToken"] : <any>null;
            this.commonName = _data["commonName"] !== undefined ? _data["commonName"] : <any>null;
            this.issueTime = _data["issueTime"] ? new Date(_data["issueTime"].toString()) : <any>null;
            this.expirationTime = _data["expirationTime"] ? new Date(_data["expirationTime"].toString()) : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.thumbprint = _data["thumbprint"] !== undefined ? _data["thumbprint"] : <any>null;
            this.isValidated = _data["isValidated"] !== undefined ? _data["isValidated"] : <any>null;
            this.autoValidate = _data["autoValidate"] !== undefined ? _data["autoValidate"] : <any>null;
            this.validateCount = _data["validateCount"] !== undefined ? _data["validateCount"] : <any>null;
            this.validateInprogress = _data["validateInprogress"] !== undefined ? _data["validateInprogress"] : <any>null;
            this.validateErrorCount = _data["validateErrorCount"] !== undefined ? _data["validateErrorCount"] : <any>null;
            this.validateError = _data["validateError"] !== undefined ? _data["validateError"] : <any>null;
            this.validateErrorTime = _data["validateErrorTime"] ? new Date(_data["validateErrorTime"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): Certificate {
        data = typeof data === 'object' ? data : {};
        let result = new Certificate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["certificateId"] = this.certificateId !== undefined ? this.certificateId : <any>null;
        data["isInToken"] = this.isInToken !== undefined ? this.isInToken : <any>null;
        data["commonName"] = this.commonName !== undefined ? this.commonName : <any>null;
        data["issueTime"] = this.issueTime ? this.issueTime.toISOString() : <any>null;
        data["expirationTime"] = this.expirationTime ? this.expirationTime.toISOString() : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["thumbprint"] = this.thumbprint !== undefined ? this.thumbprint : <any>null;
        data["isValidated"] = this.isValidated !== undefined ? this.isValidated : <any>null;
        data["autoValidate"] = this.autoValidate !== undefined ? this.autoValidate : <any>null;
        data["validateCount"] = this.validateCount !== undefined ? this.validateCount : <any>null;
        data["validateInprogress"] = this.validateInprogress !== undefined ? this.validateInprogress : <any>null;
        data["validateErrorCount"] = this.validateErrorCount !== undefined ? this.validateErrorCount : <any>null;
        data["validateError"] = this.validateError !== undefined ? this.validateError : <any>null;
        data["validateErrorTime"] = this.validateErrorTime ? this.validateErrorTime.toISOString() : <any>null;
        return data;
    }
}

export interface ICertificate {
    certificateId: string;
    isInToken: boolean;
    commonName: string;
    issueTime: Date;
    expirationTime: Date;
    createdTime: Date;
    thumbprint: string;
    isValidated: boolean;
    autoValidate: boolean;
    validateCount: number;
    validateInprogress: boolean;
    validateErrorCount: number;
    validateError?: string | null;
    validateErrorTime?: Date | null;
}

export class AccessPointView implements IAccessPointView {
    serverFarmId!: string;
    serverId!: string;
    serverName!: string;
    tcpEndPoint!: string;

    constructor(data?: IAccessPointView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serverFarmId = _data["serverFarmId"] !== undefined ? _data["serverFarmId"] : <any>null;
            this.serverId = _data["serverId"] !== undefined ? _data["serverId"] : <any>null;
            this.serverName = _data["serverName"] !== undefined ? _data["serverName"] : <any>null;
            this.tcpEndPoint = _data["tcpEndPoint"] !== undefined ? _data["tcpEndPoint"] : <any>null;
        }
    }

    static fromJS(data: any): AccessPointView {
        data = typeof data === 'object' ? data : {};
        let result = new AccessPointView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverFarmId"] = this.serverFarmId !== undefined ? this.serverFarmId : <any>null;
        data["serverId"] = this.serverId !== undefined ? this.serverId : <any>null;
        data["serverName"] = this.serverName !== undefined ? this.serverName : <any>null;
        data["tcpEndPoint"] = this.tcpEndPoint !== undefined ? this.tcpEndPoint : <any>null;
        return data;
    }
}

export interface IAccessPointView {
    serverFarmId: string;
    serverId: string;
    serverName: string;
    tcpEndPoint: string;
}

export class ServerFarmSummary implements IServerFarmSummary {
    totalTokenCount!: number;
    activeTokenCount!: number;
    inactiveTokenCount!: number;
    unusedTokenCount!: number;
    serverCount!: number;

    constructor(data?: IServerFarmSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalTokenCount = _data["totalTokenCount"] !== undefined ? _data["totalTokenCount"] : <any>null;
            this.activeTokenCount = _data["activeTokenCount"] !== undefined ? _data["activeTokenCount"] : <any>null;
            this.inactiveTokenCount = _data["inactiveTokenCount"] !== undefined ? _data["inactiveTokenCount"] : <any>null;
            this.unusedTokenCount = _data["unusedTokenCount"] !== undefined ? _data["unusedTokenCount"] : <any>null;
            this.serverCount = _data["serverCount"] !== undefined ? _data["serverCount"] : <any>null;
        }
    }

    static fromJS(data: any): ServerFarmSummary {
        data = typeof data === 'object' ? data : {};
        let result = new ServerFarmSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalTokenCount"] = this.totalTokenCount !== undefined ? this.totalTokenCount : <any>null;
        data["activeTokenCount"] = this.activeTokenCount !== undefined ? this.activeTokenCount : <any>null;
        data["inactiveTokenCount"] = this.inactiveTokenCount !== undefined ? this.inactiveTokenCount : <any>null;
        data["unusedTokenCount"] = this.unusedTokenCount !== undefined ? this.unusedTokenCount : <any>null;
        data["serverCount"] = this.serverCount !== undefined ? this.serverCount : <any>null;
        return data;
    }
}

export interface IServerFarmSummary {
    totalTokenCount: number;
    activeTokenCount: number;
    inactiveTokenCount: number;
    unusedTokenCount: number;
    serverCount: number;
}

export class ServerFarmCreateParams implements IServerFarmCreateParams {
    serverFarmName?: string | null;
    serverProfileId?: string | null;

    constructor(data?: IServerFarmCreateParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serverFarmName = _data["serverFarmName"] !== undefined ? _data["serverFarmName"] : <any>null;
            this.serverProfileId = _data["serverProfileId"] !== undefined ? _data["serverProfileId"] : <any>null;
        }
    }

    static fromJS(data: any): ServerFarmCreateParams {
        data = typeof data === 'object' ? data : {};
        let result = new ServerFarmCreateParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverFarmName"] = this.serverFarmName !== undefined ? this.serverFarmName : <any>null;
        data["serverProfileId"] = this.serverProfileId !== undefined ? this.serverProfileId : <any>null;
        return data;
    }
}

export interface IServerFarmCreateParams {
    serverFarmName?: string | null;
    serverProfileId?: string | null;
}

export class ServerFarmUpdateParams implements IServerFarmUpdateParams {
    serverFarmName?: PatchOfString | null;
    serverProfileId?: PatchOfGuid | null;
    useHostName?: PatchOfBoolean | null;
    secret?: PatchOfByteOf | null;
    pushTokenToClient?: PatchOfBoolean | null;
    autoValidateCertificate?: PatchOfBoolean | null;
    maxCertificateCount?: PatchOfInteger | null;
    tokenRepos?: PatchOfFarmTokenRepoOf | null;

    constructor(data?: IServerFarmUpdateParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serverFarmName = _data["serverFarmName"] ? PatchOfString.fromJS(_data["serverFarmName"]) : <any>null;
            this.serverProfileId = _data["serverProfileId"] ? PatchOfGuid.fromJS(_data["serverProfileId"]) : <any>null;
            this.useHostName = _data["useHostName"] ? PatchOfBoolean.fromJS(_data["useHostName"]) : <any>null;
            this.secret = _data["secret"] ? PatchOfByteOf.fromJS(_data["secret"]) : <any>null;
            this.pushTokenToClient = _data["pushTokenToClient"] ? PatchOfBoolean.fromJS(_data["pushTokenToClient"]) : <any>null;
            this.autoValidateCertificate = _data["autoValidateCertificate"] ? PatchOfBoolean.fromJS(_data["autoValidateCertificate"]) : <any>null;
            this.maxCertificateCount = _data["maxCertificateCount"] ? PatchOfInteger.fromJS(_data["maxCertificateCount"]) : <any>null;
            this.tokenRepos = _data["tokenRepos"] ? PatchOfFarmTokenRepoOf.fromJS(_data["tokenRepos"]) : <any>null;
        }
    }

    static fromJS(data: any): ServerFarmUpdateParams {
        data = typeof data === 'object' ? data : {};
        let result = new ServerFarmUpdateParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverFarmName"] = this.serverFarmName ? this.serverFarmName.toJSON() : <any>null;
        data["serverProfileId"] = this.serverProfileId ? this.serverProfileId.toJSON() : <any>null;
        data["useHostName"] = this.useHostName ? this.useHostName.toJSON() : <any>null;
        data["secret"] = this.secret ? this.secret.toJSON() : <any>null;
        data["pushTokenToClient"] = this.pushTokenToClient ? this.pushTokenToClient.toJSON() : <any>null;
        data["autoValidateCertificate"] = this.autoValidateCertificate ? this.autoValidateCertificate.toJSON() : <any>null;
        data["maxCertificateCount"] = this.maxCertificateCount ? this.maxCertificateCount.toJSON() : <any>null;
        data["tokenRepos"] = this.tokenRepos ? this.tokenRepos.toJSON() : <any>null;
        return data;
    }
}

export interface IServerFarmUpdateParams {
    serverFarmName?: PatchOfString | null;
    serverProfileId?: PatchOfGuid | null;
    useHostName?: PatchOfBoolean | null;
    secret?: PatchOfByteOf | null;
    pushTokenToClient?: PatchOfBoolean | null;
    autoValidateCertificate?: PatchOfBoolean | null;
    maxCertificateCount?: PatchOfInteger | null;
    tokenRepos?: PatchOfFarmTokenRepoOf | null;
}

export class PatchOfByteOf implements IPatchOfByteOf {
    value?: string | null;

    constructor(data?: IPatchOfByteOf) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): PatchOfByteOf {
        data = typeof data === 'object' ? data : {};
        let result = new PatchOfByteOf();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }
}

export interface IPatchOfByteOf {
    value?: string | null;
}

export class PatchOfFarmTokenRepoOf implements IPatchOfFarmTokenRepoOf {
    value?: FarmTokenRepo[] | null;

    constructor(data?: IPatchOfFarmTokenRepoOf) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(FarmTokenRepo.fromJS(item));
            }
            else {
                this.value = <any>null;
            }
        }
    }

    static fromJS(data: any): PatchOfFarmTokenRepoOf {
        data = typeof data === 'object' ? data : {};
        let result = new PatchOfFarmTokenRepoOf();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPatchOfFarmTokenRepoOf {
    value?: FarmTokenRepo[] | null;
}

export class CertificateImportParams implements ICertificateImportParams {
    rawData!: string;
    password?: string | null;

    constructor(data?: ICertificateImportParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rawData = _data["rawData"] !== undefined ? _data["rawData"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): CertificateImportParams {
        data = typeof data === 'object' ? data : {};
        let result = new CertificateImportParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rawData"] = this.rawData !== undefined ? this.rawData : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data;
    }
}

export interface ICertificateImportParams {
    rawData: string;
    password?: string | null;
}

export class CertificateCreateParams implements ICertificateCreateParams {
    certificateSigningRequest!: CertificateSigningRequest;
    expirationTime?: Date | null;

    constructor(data?: ICertificateCreateParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.certificateSigningRequest = new CertificateSigningRequest();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.certificateSigningRequest = _data["certificateSigningRequest"] ? CertificateSigningRequest.fromJS(_data["certificateSigningRequest"]) : new CertificateSigningRequest();
            this.expirationTime = _data["expirationTime"] ? new Date(_data["expirationTime"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): CertificateCreateParams {
        data = typeof data === 'object' ? data : {};
        let result = new CertificateCreateParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["certificateSigningRequest"] = this.certificateSigningRequest ? this.certificateSigningRequest.toJSON() : <any>null;
        data["expirationTime"] = this.expirationTime ? this.expirationTime.toISOString() : <any>null;
        return data;
    }
}

export interface ICertificateCreateParams {
    certificateSigningRequest: CertificateSigningRequest;
    expirationTime?: Date | null;
}

export class CertificateSigningRequest implements ICertificateSigningRequest {
    commonName?: string | null;
    organization?: string | null;
    organizationUnit?: string | null;
    locationCountry?: string | null;
    locationState?: string | null;
    locationCity?: string | null;

    constructor(data?: ICertificateSigningRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.commonName = _data["commonName"] !== undefined ? _data["commonName"] : <any>null;
            this.organization = _data["organization"] !== undefined ? _data["organization"] : <any>null;
            this.organizationUnit = _data["organizationUnit"] !== undefined ? _data["organizationUnit"] : <any>null;
            this.locationCountry = _data["locationCountry"] !== undefined ? _data["locationCountry"] : <any>null;
            this.locationState = _data["locationState"] !== undefined ? _data["locationState"] : <any>null;
            this.locationCity = _data["locationCity"] !== undefined ? _data["locationCity"] : <any>null;
        }
    }

    static fromJS(data: any): CertificateSigningRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CertificateSigningRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["commonName"] = this.commonName !== undefined ? this.commonName : <any>null;
        data["organization"] = this.organization !== undefined ? this.organization : <any>null;
        data["organizationUnit"] = this.organizationUnit !== undefined ? this.organizationUnit : <any>null;
        data["locationCountry"] = this.locationCountry !== undefined ? this.locationCountry : <any>null;
        data["locationState"] = this.locationState !== undefined ? this.locationState : <any>null;
        data["locationCity"] = this.locationCity !== undefined ? this.locationCity : <any>null;
        return data;
    }
}

export interface ICertificateSigningRequest {
    commonName?: string | null;
    organization?: string | null;
    organizationUnit?: string | null;
    locationCountry?: string | null;
    locationState?: string | null;
    locationCity?: string | null;
}

export class ServerProfile implements IServerProfile {
    serverProfileId!: string;
    serverProfileName!: string;
    isDefault!: boolean;
    createdTime!: Date;
    serverConfig?: string | null;

    constructor(data?: IServerProfile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serverProfileId = _data["serverProfileId"] !== undefined ? _data["serverProfileId"] : <any>null;
            this.serverProfileName = _data["serverProfileName"] !== undefined ? _data["serverProfileName"] : <any>null;
            this.isDefault = _data["isDefault"] !== undefined ? _data["isDefault"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.serverConfig = _data["serverConfig"] !== undefined ? _data["serverConfig"] : <any>null;
        }
    }

    static fromJS(data: any): ServerProfile {
        data = typeof data === 'object' ? data : {};
        let result = new ServerProfile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverProfileId"] = this.serverProfileId !== undefined ? this.serverProfileId : <any>null;
        data["serverProfileName"] = this.serverProfileName !== undefined ? this.serverProfileName : <any>null;
        data["isDefault"] = this.isDefault !== undefined ? this.isDefault : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["serverConfig"] = this.serverConfig !== undefined ? this.serverConfig : <any>null;
        return data;
    }
}

export interface IServerProfile {
    serverProfileId: string;
    serverProfileName: string;
    isDefault: boolean;
    createdTime: Date;
    serverConfig?: string | null;
}

export class ServerProfileCreateParams implements IServerProfileCreateParams {
    serverProfileName?: string | null;
    serverConfig?: string | null;

    constructor(data?: IServerProfileCreateParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serverProfileName = _data["serverProfileName"] !== undefined ? _data["serverProfileName"] : <any>null;
            this.serverConfig = _data["serverConfig"] !== undefined ? _data["serverConfig"] : <any>null;
        }
    }

    static fromJS(data: any): ServerProfileCreateParams {
        data = typeof data === 'object' ? data : {};
        let result = new ServerProfileCreateParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverProfileName"] = this.serverProfileName !== undefined ? this.serverProfileName : <any>null;
        data["serverConfig"] = this.serverConfig !== undefined ? this.serverConfig : <any>null;
        return data;
    }
}

export interface IServerProfileCreateParams {
    serverProfileName?: string | null;
    serverConfig?: string | null;
}

export class ServerProfileData implements IServerProfileData {
    serverProfile!: ServerProfile;
    summary?: ServerProfileSummary | null;

    constructor(data?: IServerProfileData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.serverProfile = new ServerProfile();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serverProfile = _data["serverProfile"] ? ServerProfile.fromJS(_data["serverProfile"]) : new ServerProfile();
            this.summary = _data["summary"] ? ServerProfileSummary.fromJS(_data["summary"]) : <any>null;
        }
    }

    static fromJS(data: any): ServerProfileData {
        data = typeof data === 'object' ? data : {};
        let result = new ServerProfileData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverProfile"] = this.serverProfile ? this.serverProfile.toJSON() : <any>null;
        data["summary"] = this.summary ? this.summary.toJSON() : <any>null;
        return data;
    }
}

export interface IServerProfileData {
    serverProfile: ServerProfile;
    summary?: ServerProfileSummary | null;
}

export class ServerProfileSummary implements IServerProfileSummary {
    serverCount!: number;
    serverFarmCount!: number;

    constructor(data?: IServerProfileSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serverCount = _data["serverCount"] !== undefined ? _data["serverCount"] : <any>null;
            this.serverFarmCount = _data["serverFarmCount"] !== undefined ? _data["serverFarmCount"] : <any>null;
        }
    }

    static fromJS(data: any): ServerProfileSummary {
        data = typeof data === 'object' ? data : {};
        let result = new ServerProfileSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverCount"] = this.serverCount !== undefined ? this.serverCount : <any>null;
        data["serverFarmCount"] = this.serverFarmCount !== undefined ? this.serverFarmCount : <any>null;
        return data;
    }
}

export interface IServerProfileSummary {
    serverCount: number;
    serverFarmCount: number;
}

export class ServerProfileUpdateParams implements IServerProfileUpdateParams {
    serverProfileName?: PatchOfString | null;
    serverConfig?: PatchOfString | null;

    constructor(data?: IServerProfileUpdateParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serverProfileName = _data["serverProfileName"] ? PatchOfString.fromJS(_data["serverProfileName"]) : <any>null;
            this.serverConfig = _data["serverConfig"] ? PatchOfString.fromJS(_data["serverConfig"]) : <any>null;
        }
    }

    static fromJS(data: any): ServerProfileUpdateParams {
        data = typeof data === 'object' ? data : {};
        let result = new ServerProfileUpdateParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverProfileName"] = this.serverProfileName ? this.serverProfileName.toJSON() : <any>null;
        data["serverConfig"] = this.serverConfig ? this.serverConfig.toJSON() : <any>null;
        return data;
    }
}

export interface IServerProfileUpdateParams {
    serverProfileName?: PatchOfString | null;
    serverConfig?: PatchOfString | null;
}

export class ServerData implements IServerData {
    server!: VpnServer;

    constructor(data?: IServerData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.server = new VpnServer();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.server = _data["server"] ? VpnServer.fromJS(_data["server"]) : new VpnServer();
        }
    }

    static fromJS(data: any): ServerData {
        data = typeof data === 'object' ? data : {};
        let result = new ServerData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["server"] = this.server ? this.server.toJSON() : <any>null;
        return data;
    }
}

export interface IServerData {
    server: VpnServer;
}

export class VpnServer implements IVpnServer {
    serverId!: string;
    serverName!: string;
    serverFarmId!: string;
    serverFarmName?: string | null;
    location?: Location | null;
    version?: string | null;
    environmentVersion?: string | null;
    osInfo?: string | null;
    machineName?: string | null;
    totalMemory?: number | null;
    logicalCoreCount?: number | null;
    configureTime?: Date | null;
    createdTime!: Date;
    autoConfigure!: boolean;
    isEnabled!: boolean;
    description?: string | null;
    lastConfigError?: string | null;
    serverState!: ServerState;
    serverStatus?: ServerStatusEx | null;
    accessPoints!: AccessPoint[];
    allowInAutoLocation!: boolean;
    hostPanelUrl?: string | null;
    power?: number | null;
    gatewayIpV4?: string | null;
    gatewayIpV6?: string | null;

    constructor(data?: IVpnServer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.accessPoints = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serverId = _data["serverId"] !== undefined ? _data["serverId"] : <any>null;
            this.serverName = _data["serverName"] !== undefined ? _data["serverName"] : <any>null;
            this.serverFarmId = _data["serverFarmId"] !== undefined ? _data["serverFarmId"] : <any>null;
            this.serverFarmName = _data["serverFarmName"] !== undefined ? _data["serverFarmName"] : <any>null;
            this.location = _data["location"] ? Location.fromJS(_data["location"]) : <any>null;
            this.version = _data["version"] !== undefined ? _data["version"] : <any>null;
            this.environmentVersion = _data["environmentVersion"] !== undefined ? _data["environmentVersion"] : <any>null;
            this.osInfo = _data["osInfo"] !== undefined ? _data["osInfo"] : <any>null;
            this.machineName = _data["machineName"] !== undefined ? _data["machineName"] : <any>null;
            this.totalMemory = _data["totalMemory"] !== undefined ? _data["totalMemory"] : <any>null;
            this.logicalCoreCount = _data["logicalCoreCount"] !== undefined ? _data["logicalCoreCount"] : <any>null;
            this.configureTime = _data["configureTime"] ? new Date(_data["configureTime"].toString()) : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.autoConfigure = _data["autoConfigure"] !== undefined ? _data["autoConfigure"] : <any>null;
            this.isEnabled = _data["isEnabled"] !== undefined ? _data["isEnabled"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.lastConfigError = _data["lastConfigError"] !== undefined ? _data["lastConfigError"] : <any>null;
            this.serverState = _data["serverState"] !== undefined ? _data["serverState"] : <any>null;
            this.serverStatus = _data["serverStatus"] ? ServerStatusEx.fromJS(_data["serverStatus"]) : <any>null;
            if (Array.isArray(_data["accessPoints"])) {
                this.accessPoints = [] as any;
                for (let item of _data["accessPoints"])
                    this.accessPoints!.push(AccessPoint.fromJS(item));
            }
            else {
                this.accessPoints = <any>null;
            }
            this.allowInAutoLocation = _data["allowInAutoLocation"] !== undefined ? _data["allowInAutoLocation"] : <any>null;
            this.hostPanelUrl = _data["hostPanelUrl"] !== undefined ? _data["hostPanelUrl"] : <any>null;
            this.power = _data["power"] !== undefined ? _data["power"] : <any>null;
            this.gatewayIpV4 = _data["gatewayIpV4"] !== undefined ? _data["gatewayIpV4"] : <any>null;
            this.gatewayIpV6 = _data["gatewayIpV6"] !== undefined ? _data["gatewayIpV6"] : <any>null;
        }
    }

    static fromJS(data: any): VpnServer {
        data = typeof data === 'object' ? data : {};
        let result = new VpnServer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverId"] = this.serverId !== undefined ? this.serverId : <any>null;
        data["serverName"] = this.serverName !== undefined ? this.serverName : <any>null;
        data["serverFarmId"] = this.serverFarmId !== undefined ? this.serverFarmId : <any>null;
        data["serverFarmName"] = this.serverFarmName !== undefined ? this.serverFarmName : <any>null;
        data["location"] = this.location ? this.location.toJSON() : <any>null;
        data["version"] = this.version !== undefined ? this.version : <any>null;
        data["environmentVersion"] = this.environmentVersion !== undefined ? this.environmentVersion : <any>null;
        data["osInfo"] = this.osInfo !== undefined ? this.osInfo : <any>null;
        data["machineName"] = this.machineName !== undefined ? this.machineName : <any>null;
        data["totalMemory"] = this.totalMemory !== undefined ? this.totalMemory : <any>null;
        data["logicalCoreCount"] = this.logicalCoreCount !== undefined ? this.logicalCoreCount : <any>null;
        data["configureTime"] = this.configureTime ? this.configureTime.toISOString() : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["autoConfigure"] = this.autoConfigure !== undefined ? this.autoConfigure : <any>null;
        data["isEnabled"] = this.isEnabled !== undefined ? this.isEnabled : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["lastConfigError"] = this.lastConfigError !== undefined ? this.lastConfigError : <any>null;
        data["serverState"] = this.serverState !== undefined ? this.serverState : <any>null;
        data["serverStatus"] = this.serverStatus ? this.serverStatus.toJSON() : <any>null;
        if (Array.isArray(this.accessPoints)) {
            data["accessPoints"] = [];
            for (let item of this.accessPoints)
                data["accessPoints"].push(item.toJSON());
        }
        data["allowInAutoLocation"] = this.allowInAutoLocation !== undefined ? this.allowInAutoLocation : <any>null;
        data["hostPanelUrl"] = this.hostPanelUrl !== undefined ? this.hostPanelUrl : <any>null;
        data["power"] = this.power !== undefined ? this.power : <any>null;
        data["gatewayIpV4"] = this.gatewayIpV4 !== undefined ? this.gatewayIpV4 : <any>null;
        data["gatewayIpV6"] = this.gatewayIpV6 !== undefined ? this.gatewayIpV6 : <any>null;
        return data;
    }
}

export interface IVpnServer {
    serverId: string;
    serverName: string;
    serverFarmId: string;
    serverFarmName?: string | null;
    location?: Location | null;
    version?: string | null;
    environmentVersion?: string | null;
    osInfo?: string | null;
    machineName?: string | null;
    totalMemory?: number | null;
    logicalCoreCount?: number | null;
    configureTime?: Date | null;
    createdTime: Date;
    autoConfigure: boolean;
    isEnabled: boolean;
    description?: string | null;
    lastConfigError?: string | null;
    serverState: ServerState;
    serverStatus?: ServerStatusEx | null;
    accessPoints: AccessPoint[];
    allowInAutoLocation: boolean;
    hostPanelUrl?: string | null;
    power?: number | null;
    gatewayIpV4?: string | null;
    gatewayIpV6?: string | null;
}

export enum ServerState {
    NotInstalled = "NotInstalled",
    Disabled = "Disabled",
    Lost = "Lost",
    Error = "Error",
    Configuring = "Configuring",
    Idle = "Idle",
    Active = "Active",
}

export class ServerStatusEx implements IServerStatusEx {
    sessionCount!: number;
    tcpConnectionCount!: number;
    udpConnectionCount!: number;
    availableMemory?: number | null;
    cpuUsage?: number | null;
    threadCount!: number;
    tunnelSendSpeed!: number;
    tunnelReceiveSpeed!: number;
    createdTime!: Date;

    constructor(data?: IServerStatusEx) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sessionCount = _data["sessionCount"] !== undefined ? _data["sessionCount"] : <any>null;
            this.tcpConnectionCount = _data["tcpConnectionCount"] !== undefined ? _data["tcpConnectionCount"] : <any>null;
            this.udpConnectionCount = _data["udpConnectionCount"] !== undefined ? _data["udpConnectionCount"] : <any>null;
            this.availableMemory = _data["availableMemory"] !== undefined ? _data["availableMemory"] : <any>null;
            this.cpuUsage = _data["cpuUsage"] !== undefined ? _data["cpuUsage"] : <any>null;
            this.threadCount = _data["threadCount"] !== undefined ? _data["threadCount"] : <any>null;
            this.tunnelSendSpeed = _data["tunnelSendSpeed"] !== undefined ? _data["tunnelSendSpeed"] : <any>null;
            this.tunnelReceiveSpeed = _data["tunnelReceiveSpeed"] !== undefined ? _data["tunnelReceiveSpeed"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): ServerStatusEx {
        data = typeof data === 'object' ? data : {};
        let result = new ServerStatusEx();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sessionCount"] = this.sessionCount !== undefined ? this.sessionCount : <any>null;
        data["tcpConnectionCount"] = this.tcpConnectionCount !== undefined ? this.tcpConnectionCount : <any>null;
        data["udpConnectionCount"] = this.udpConnectionCount !== undefined ? this.udpConnectionCount : <any>null;
        data["availableMemory"] = this.availableMemory !== undefined ? this.availableMemory : <any>null;
        data["cpuUsage"] = this.cpuUsage !== undefined ? this.cpuUsage : <any>null;
        data["threadCount"] = this.threadCount !== undefined ? this.threadCount : <any>null;
        data["tunnelSendSpeed"] = this.tunnelSendSpeed !== undefined ? this.tunnelSendSpeed : <any>null;
        data["tunnelReceiveSpeed"] = this.tunnelReceiveSpeed !== undefined ? this.tunnelReceiveSpeed : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        return data;
    }
}

export interface IServerStatusEx {
    sessionCount: number;
    tcpConnectionCount: number;
    udpConnectionCount: number;
    availableMemory?: number | null;
    cpuUsage?: number | null;
    threadCount: number;
    tunnelSendSpeed: number;
    tunnelReceiveSpeed: number;
    createdTime: Date;
}

export class AccessPoint implements IAccessPoint {
    ipAddress!: string;
    accessPointMode!: AccessPointMode;
    isListen!: boolean;
    tcpPort!: number;
    udpPort!: number;

    constructor(data?: IAccessPoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ipAddress = _data["ipAddress"] !== undefined ? _data["ipAddress"] : <any>null;
            this.accessPointMode = _data["accessPointMode"] !== undefined ? _data["accessPointMode"] : <any>null;
            this.isListen = _data["isListen"] !== undefined ? _data["isListen"] : <any>null;
            this.tcpPort = _data["tcpPort"] !== undefined ? _data["tcpPort"] : <any>null;
            this.udpPort = _data["udpPort"] !== undefined ? _data["udpPort"] : <any>null;
        }
    }

    static fromJS(data: any): AccessPoint {
        data = typeof data === 'object' ? data : {};
        let result = new AccessPoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ipAddress"] = this.ipAddress !== undefined ? this.ipAddress : <any>null;
        data["accessPointMode"] = this.accessPointMode !== undefined ? this.accessPointMode : <any>null;
        data["isListen"] = this.isListen !== undefined ? this.isListen : <any>null;
        data["tcpPort"] = this.tcpPort !== undefined ? this.tcpPort : <any>null;
        data["udpPort"] = this.udpPort !== undefined ? this.udpPort : <any>null;
        return data;
    }
}

export interface IAccessPoint {
    ipAddress: string;
    accessPointMode: AccessPointMode;
    isListen: boolean;
    tcpPort: number;
    udpPort: number;
}

export enum AccessPointMode {
    Private = "Private",
    Public = "Public",
    PublicInToken = "PublicInToken",
}

export class ServerCreateParams implements IServerCreateParams {
    serverName?: string | null;
    serverFarmId!: string;
    hostPanelUrl?: string | null;
    accessPoints?: AccessPoint[] | null;
    power?: number | null;

    constructor(data?: IServerCreateParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serverName = _data["serverName"] !== undefined ? _data["serverName"] : <any>null;
            this.serverFarmId = _data["serverFarmId"] !== undefined ? _data["serverFarmId"] : <any>null;
            this.hostPanelUrl = _data["hostPanelUrl"] !== undefined ? _data["hostPanelUrl"] : <any>null;
            if (Array.isArray(_data["accessPoints"])) {
                this.accessPoints = [] as any;
                for (let item of _data["accessPoints"])
                    this.accessPoints!.push(AccessPoint.fromJS(item));
            }
            else {
                this.accessPoints = <any>null;
            }
            this.power = _data["power"] !== undefined ? _data["power"] : <any>null;
        }
    }

    static fromJS(data: any): ServerCreateParams {
        data = typeof data === 'object' ? data : {};
        let result = new ServerCreateParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverName"] = this.serverName !== undefined ? this.serverName : <any>null;
        data["serverFarmId"] = this.serverFarmId !== undefined ? this.serverFarmId : <any>null;
        data["hostPanelUrl"] = this.hostPanelUrl !== undefined ? this.hostPanelUrl : <any>null;
        if (Array.isArray(this.accessPoints)) {
            data["accessPoints"] = [];
            for (let item of this.accessPoints)
                data["accessPoints"].push(item.toJSON());
        }
        data["power"] = this.power !== undefined ? this.power : <any>null;
        return data;
    }
}

export interface IServerCreateParams {
    serverName?: string | null;
    serverFarmId: string;
    hostPanelUrl?: string | null;
    accessPoints?: AccessPoint[] | null;
    power?: number | null;
}

export class ServerUpdateParams implements IServerUpdateParams {
    serverName?: PatchOfString | null;
    serverFarmId?: PatchOfGuid | null;
    generateNewSecret?: PatchOfBoolean | null;
    autoConfigure?: PatchOfBoolean | null;
    accessPoints?: PatchOfAccessPointOf | null;
    allowInAutoLocation?: PatchOfBoolean | null;
    hostPanelUrl?: PatchOfUri | null;
    power?: PatchOfNullableInteger | null;
    isEnabled?: PatchOfBoolean | null;

    constructor(data?: IServerUpdateParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serverName = _data["serverName"] ? PatchOfString.fromJS(_data["serverName"]) : <any>null;
            this.serverFarmId = _data["serverFarmId"] ? PatchOfGuid.fromJS(_data["serverFarmId"]) : <any>null;
            this.generateNewSecret = _data["generateNewSecret"] ? PatchOfBoolean.fromJS(_data["generateNewSecret"]) : <any>null;
            this.autoConfigure = _data["autoConfigure"] ? PatchOfBoolean.fromJS(_data["autoConfigure"]) : <any>null;
            this.accessPoints = _data["accessPoints"] ? PatchOfAccessPointOf.fromJS(_data["accessPoints"]) : <any>null;
            this.allowInAutoLocation = _data["allowInAutoLocation"] ? PatchOfBoolean.fromJS(_data["allowInAutoLocation"]) : <any>null;
            this.hostPanelUrl = _data["hostPanelUrl"] ? PatchOfUri.fromJS(_data["hostPanelUrl"]) : <any>null;
            this.power = _data["power"] ? PatchOfNullableInteger.fromJS(_data["power"]) : <any>null;
            this.isEnabled = _data["isEnabled"] ? PatchOfBoolean.fromJS(_data["isEnabled"]) : <any>null;
        }
    }

    static fromJS(data: any): ServerUpdateParams {
        data = typeof data === 'object' ? data : {};
        let result = new ServerUpdateParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverName"] = this.serverName ? this.serverName.toJSON() : <any>null;
        data["serverFarmId"] = this.serverFarmId ? this.serverFarmId.toJSON() : <any>null;
        data["generateNewSecret"] = this.generateNewSecret ? this.generateNewSecret.toJSON() : <any>null;
        data["autoConfigure"] = this.autoConfigure ? this.autoConfigure.toJSON() : <any>null;
        data["accessPoints"] = this.accessPoints ? this.accessPoints.toJSON() : <any>null;
        data["allowInAutoLocation"] = this.allowInAutoLocation ? this.allowInAutoLocation.toJSON() : <any>null;
        data["hostPanelUrl"] = this.hostPanelUrl ? this.hostPanelUrl.toJSON() : <any>null;
        data["power"] = this.power ? this.power.toJSON() : <any>null;
        data["isEnabled"] = this.isEnabled ? this.isEnabled.toJSON() : <any>null;
        return data;
    }
}

export interface IServerUpdateParams {
    serverName?: PatchOfString | null;
    serverFarmId?: PatchOfGuid | null;
    generateNewSecret?: PatchOfBoolean | null;
    autoConfigure?: PatchOfBoolean | null;
    accessPoints?: PatchOfAccessPointOf | null;
    allowInAutoLocation?: PatchOfBoolean | null;
    hostPanelUrl?: PatchOfUri | null;
    power?: PatchOfNullableInteger | null;
    isEnabled?: PatchOfBoolean | null;
}

export class PatchOfAccessPointOf implements IPatchOfAccessPointOf {
    value?: AccessPoint[] | null;

    constructor(data?: IPatchOfAccessPointOf) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(AccessPoint.fromJS(item));
            }
            else {
                this.value = <any>null;
            }
        }
    }

    static fromJS(data: any): PatchOfAccessPointOf {
        data = typeof data === 'object' ? data : {};
        let result = new PatchOfAccessPointOf();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPatchOfAccessPointOf {
    value?: AccessPoint[] | null;
}

export class PatchOfNullableInteger implements IPatchOfNullableInteger {
    value?: number | null;

    constructor(data?: IPatchOfNullableInteger) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): PatchOfNullableInteger {
        data = typeof data === 'object' ? data : {};
        let result = new PatchOfNullableInteger();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }
}

export interface IPatchOfNullableInteger {
    value?: number | null;
}

export class ServerInstallBySshUserPasswordParams implements IServerInstallBySshUserPasswordParams {
    hostName!: string;
    hostPort!: number;
    loginUserName!: string;
    loginPassword!: string;

    constructor(data?: IServerInstallBySshUserPasswordParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hostName = _data["hostName"] !== undefined ? _data["hostName"] : <any>null;
            this.hostPort = _data["hostPort"] !== undefined ? _data["hostPort"] : <any>null;
            this.loginUserName = _data["loginUserName"] !== undefined ? _data["loginUserName"] : <any>null;
            this.loginPassword = _data["loginPassword"] !== undefined ? _data["loginPassword"] : <any>null;
        }
    }

    static fromJS(data: any): ServerInstallBySshUserPasswordParams {
        data = typeof data === 'object' ? data : {};
        let result = new ServerInstallBySshUserPasswordParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hostName"] = this.hostName !== undefined ? this.hostName : <any>null;
        data["hostPort"] = this.hostPort !== undefined ? this.hostPort : <any>null;
        data["loginUserName"] = this.loginUserName !== undefined ? this.loginUserName : <any>null;
        data["loginPassword"] = this.loginPassword !== undefined ? this.loginPassword : <any>null;
        return data;
    }
}

export interface IServerInstallBySshUserPasswordParams {
    hostName: string;
    hostPort: number;
    loginUserName: string;
    loginPassword: string;
}

export class ServerInstallBySshUserKeyParams implements IServerInstallBySshUserKeyParams {
    hostName!: string;
    hostPort!: number;
    loginUserName!: string;
    loginPassword?: string | null;
    userPrivateKey!: string;
    userPrivateKeyPassphrase?: string | null;

    constructor(data?: IServerInstallBySshUserKeyParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hostName = _data["hostName"] !== undefined ? _data["hostName"] : <any>null;
            this.hostPort = _data["hostPort"] !== undefined ? _data["hostPort"] : <any>null;
            this.loginUserName = _data["loginUserName"] !== undefined ? _data["loginUserName"] : <any>null;
            this.loginPassword = _data["loginPassword"] !== undefined ? _data["loginPassword"] : <any>null;
            this.userPrivateKey = _data["userPrivateKey"] !== undefined ? _data["userPrivateKey"] : <any>null;
            this.userPrivateKeyPassphrase = _data["userPrivateKeyPassphrase"] !== undefined ? _data["userPrivateKeyPassphrase"] : <any>null;
        }
    }

    static fromJS(data: any): ServerInstallBySshUserKeyParams {
        data = typeof data === 'object' ? data : {};
        let result = new ServerInstallBySshUserKeyParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hostName"] = this.hostName !== undefined ? this.hostName : <any>null;
        data["hostPort"] = this.hostPort !== undefined ? this.hostPort : <any>null;
        data["loginUserName"] = this.loginUserName !== undefined ? this.loginUserName : <any>null;
        data["loginPassword"] = this.loginPassword !== undefined ? this.loginPassword : <any>null;
        data["userPrivateKey"] = this.userPrivateKey !== undefined ? this.userPrivateKey : <any>null;
        data["userPrivateKeyPassphrase"] = this.userPrivateKeyPassphrase !== undefined ? this.userPrivateKeyPassphrase : <any>null;
        return data;
    }
}

export interface IServerInstallBySshUserKeyParams {
    hostName: string;
    hostPort: number;
    loginUserName: string;
    loginPassword?: string | null;
    userPrivateKey: string;
    userPrivateKeyPassphrase?: string | null;
}

export class ServerInstallManual implements IServerInstallManual {
    appSettingsJson!: string;
    appSettings!: ServerInstallAppSettings;
    linuxCommand!: string;
    windowsCommand!: string;

    constructor(data?: IServerInstallManual) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.appSettings = new ServerInstallAppSettings();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appSettingsJson = _data["appSettingsJson"] !== undefined ? _data["appSettingsJson"] : <any>null;
            this.appSettings = _data["appSettings"] ? ServerInstallAppSettings.fromJS(_data["appSettings"]) : new ServerInstallAppSettings();
            this.linuxCommand = _data["linuxCommand"] !== undefined ? _data["linuxCommand"] : <any>null;
            this.windowsCommand = _data["windowsCommand"] !== undefined ? _data["windowsCommand"] : <any>null;
        }
    }

    static fromJS(data: any): ServerInstallManual {
        data = typeof data === 'object' ? data : {};
        let result = new ServerInstallManual();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appSettingsJson"] = this.appSettingsJson !== undefined ? this.appSettingsJson : <any>null;
        data["appSettings"] = this.appSettings ? this.appSettings.toJSON() : <any>null;
        data["linuxCommand"] = this.linuxCommand !== undefined ? this.linuxCommand : <any>null;
        data["windowsCommand"] = this.windowsCommand !== undefined ? this.windowsCommand : <any>null;
        return data;
    }
}

export interface IServerInstallManual {
    appSettingsJson: string;
    appSettings: ServerInstallAppSettings;
    linuxCommand: string;
    windowsCommand: string;
}

export class ServerInstallAppSettings implements IServerInstallAppSettings {
    httpAccessManager!: HttpAccessManagerOptions;
    managementSecret!: string;

    constructor(data?: IServerInstallAppSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.httpAccessManager = new HttpAccessManagerOptions();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.httpAccessManager = _data["httpAccessManager"] ? HttpAccessManagerOptions.fromJS(_data["httpAccessManager"]) : new HttpAccessManagerOptions();
            this.managementSecret = _data["managementSecret"] !== undefined ? _data["managementSecret"] : <any>null;
        }
    }

    static fromJS(data: any): ServerInstallAppSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ServerInstallAppSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["httpAccessManager"] = this.httpAccessManager ? this.httpAccessManager.toJSON() : <any>null;
        data["managementSecret"] = this.managementSecret !== undefined ? this.managementSecret : <any>null;
        return data;
    }
}

export interface IServerInstallAppSettings {
    httpAccessManager: HttpAccessManagerOptions;
    managementSecret: string;
}

export class HttpAccessManagerOptions implements IHttpAccessManagerOptions {
    baseUrl!: string;
    authorization!: string;

    constructor(data?: IHttpAccessManagerOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.baseUrl = _data["baseUrl"] !== undefined ? _data["baseUrl"] : <any>null;
            this.authorization = _data["authorization"] !== undefined ? _data["authorization"] : <any>null;
        }
    }

    static fromJS(data: any): HttpAccessManagerOptions {
        data = typeof data === 'object' ? data : {};
        let result = new HttpAccessManagerOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseUrl"] = this.baseUrl !== undefined ? this.baseUrl : <any>null;
        data["authorization"] = this.authorization !== undefined ? this.authorization : <any>null;
        return data;
    }
}

export interface IHttpAccessManagerOptions {
    baseUrl: string;
    authorization: string;
}

export class ServersStatusSummary implements IServersStatusSummary {
    totalServerCount!: number;
    activeServerCount!: number;
    idleServerCount!: number;
    lostServerCount!: number;
    disabledServerCount!: number;
    notInstalledServerCount!: number;
    sessionCount!: number;
    tunnelSendSpeed!: number;
    tunnelReceiveSpeed!: number;
    usingBandwidth!: number;

    constructor(data?: IServersStatusSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalServerCount = _data["totalServerCount"] !== undefined ? _data["totalServerCount"] : <any>null;
            this.activeServerCount = _data["activeServerCount"] !== undefined ? _data["activeServerCount"] : <any>null;
            this.idleServerCount = _data["idleServerCount"] !== undefined ? _data["idleServerCount"] : <any>null;
            this.lostServerCount = _data["lostServerCount"] !== undefined ? _data["lostServerCount"] : <any>null;
            this.disabledServerCount = _data["disabledServerCount"] !== undefined ? _data["disabledServerCount"] : <any>null;
            this.notInstalledServerCount = _data["notInstalledServerCount"] !== undefined ? _data["notInstalledServerCount"] : <any>null;
            this.sessionCount = _data["sessionCount"] !== undefined ? _data["sessionCount"] : <any>null;
            this.tunnelSendSpeed = _data["tunnelSendSpeed"] !== undefined ? _data["tunnelSendSpeed"] : <any>null;
            this.tunnelReceiveSpeed = _data["tunnelReceiveSpeed"] !== undefined ? _data["tunnelReceiveSpeed"] : <any>null;
            this.usingBandwidth = _data["usingBandwidth"] !== undefined ? _data["usingBandwidth"] : <any>null;
        }
    }

    static fromJS(data: any): ServersStatusSummary {
        data = typeof data === 'object' ? data : {};
        let result = new ServersStatusSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalServerCount"] = this.totalServerCount !== undefined ? this.totalServerCount : <any>null;
        data["activeServerCount"] = this.activeServerCount !== undefined ? this.activeServerCount : <any>null;
        data["idleServerCount"] = this.idleServerCount !== undefined ? this.idleServerCount : <any>null;
        data["lostServerCount"] = this.lostServerCount !== undefined ? this.lostServerCount : <any>null;
        data["disabledServerCount"] = this.disabledServerCount !== undefined ? this.disabledServerCount : <any>null;
        data["notInstalledServerCount"] = this.notInstalledServerCount !== undefined ? this.notInstalledServerCount : <any>null;
        data["sessionCount"] = this.sessionCount !== undefined ? this.sessionCount : <any>null;
        data["tunnelSendSpeed"] = this.tunnelSendSpeed !== undefined ? this.tunnelSendSpeed : <any>null;
        data["tunnelReceiveSpeed"] = this.tunnelReceiveSpeed !== undefined ? this.tunnelReceiveSpeed : <any>null;
        data["usingBandwidth"] = this.usingBandwidth !== undefined ? this.usingBandwidth : <any>null;
        return data;
    }
}

export interface IServersStatusSummary {
    totalServerCount: number;
    activeServerCount: number;
    idleServerCount: number;
    lostServerCount: number;
    disabledServerCount: number;
    notInstalledServerCount: number;
    sessionCount: number;
    tunnelSendSpeed: number;
    tunnelReceiveSpeed: number;
    usingBandwidth: number;
}

export class ApiKey implements IApiKey {
    accessToken!: Token;
    refreshToken?: Token | null;
    userId!: string;

    constructor(data?: IApiKey) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.accessToken = new Token();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"] ? Token.fromJS(_data["accessToken"]) : new Token();
            this.refreshToken = _data["refreshToken"] ? Token.fromJS(_data["refreshToken"]) : <any>null;
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
        }
    }

    static fromJS(data: any): ApiKey {
        data = typeof data === 'object' ? data : {};
        let result = new ApiKey();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken ? this.accessToken.toJSON() : <any>null;
        data["refreshToken"] = this.refreshToken ? this.refreshToken.toJSON() : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        return data;
    }
}

export interface IApiKey {
    accessToken: Token;
    refreshToken?: Token | null;
    userId: string;
}

export class Token implements IToken {
    value!: string;
    expirationTime!: Date;
    scheme!: string;
    issuedTime!: Date;

    constructor(data?: IToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
            this.expirationTime = _data["expirationTime"] ? new Date(_data["expirationTime"].toString()) : <any>null;
            this.scheme = _data["scheme"] !== undefined ? _data["scheme"] : <any>null;
            this.issuedTime = _data["issuedTime"] ? new Date(_data["issuedTime"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): Token {
        data = typeof data === 'object' ? data : {};
        let result = new Token();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value !== undefined ? this.value : <any>null;
        data["expirationTime"] = this.expirationTime ? this.expirationTime.toISOString() : <any>null;
        data["scheme"] = this.scheme !== undefined ? this.scheme : <any>null;
        data["issuedTime"] = this.issuedTime ? this.issuedTime.toISOString() : <any>null;
        return data;
    }
}

export interface IToken {
    value: string;
    expirationTime: Date;
    scheme: string;
    issuedTime: Date;
}

export class User implements IUser {
    userId!: string;
    email?: string | null;
    name?: string | null;
    firstName?: string | null;
    lastName?: string | null;
    pictureUrl?: string | null;
    phone?: string | null;
    createdTime!: Date;
    accessedTime?: Date | null;
    authorizationCode?: string | null;
    isDisabled!: boolean;
    isEmailVerified!: boolean;
    isPhoneVerified!: boolean;
    isBot!: boolean;
    description?: string | null;
    exData?: string | null;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.email = _data["email"] !== undefined ? _data["email"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.firstName = _data["firstName"] !== undefined ? _data["firstName"] : <any>null;
            this.lastName = _data["lastName"] !== undefined ? _data["lastName"] : <any>null;
            this.pictureUrl = _data["pictureUrl"] !== undefined ? _data["pictureUrl"] : <any>null;
            this.phone = _data["phone"] !== undefined ? _data["phone"] : <any>null;
            this.createdTime = _data["createdTime"] ? new Date(_data["createdTime"].toString()) : <any>null;
            this.accessedTime = _data["accessedTime"] ? new Date(_data["accessedTime"].toString()) : <any>null;
            this.authorizationCode = _data["authorizationCode"] !== undefined ? _data["authorizationCode"] : <any>null;
            this.isDisabled = _data["isDisabled"] !== undefined ? _data["isDisabled"] : <any>null;
            this.isEmailVerified = _data["isEmailVerified"] !== undefined ? _data["isEmailVerified"] : <any>null;
            this.isPhoneVerified = _data["isPhoneVerified"] !== undefined ? _data["isPhoneVerified"] : <any>null;
            this.isBot = _data["isBot"] !== undefined ? _data["isBot"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.exData = _data["exData"] !== undefined ? _data["exData"] : <any>null;
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["email"] = this.email !== undefined ? this.email : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["firstName"] = this.firstName !== undefined ? this.firstName : <any>null;
        data["lastName"] = this.lastName !== undefined ? this.lastName : <any>null;
        data["pictureUrl"] = this.pictureUrl !== undefined ? this.pictureUrl : <any>null;
        data["phone"] = this.phone !== undefined ? this.phone : <any>null;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>null;
        data["accessedTime"] = this.accessedTime ? this.accessedTime.toISOString() : <any>null;
        data["authorizationCode"] = this.authorizationCode !== undefined ? this.authorizationCode : <any>null;
        data["isDisabled"] = this.isDisabled !== undefined ? this.isDisabled : <any>null;
        data["isEmailVerified"] = this.isEmailVerified !== undefined ? this.isEmailVerified : <any>null;
        data["isPhoneVerified"] = this.isPhoneVerified !== undefined ? this.isPhoneVerified : <any>null;
        data["isBot"] = this.isBot !== undefined ? this.isBot : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["exData"] = this.exData !== undefined ? this.exData : <any>null;
        return data;
    }
}

export interface IUser {
    userId: string;
    email?: string | null;
    name?: string | null;
    firstName?: string | null;
    lastName?: string | null;
    pictureUrl?: string | null;
    phone?: string | null;
    createdTime: Date;
    accessedTime?: Date | null;
    authorizationCode?: string | null;
    isDisabled: boolean;
    isEmailVerified: boolean;
    isPhoneVerified: boolean;
    isBot: boolean;
    description?: string | null;
    exData?: string | null;
}

export class TeamUpdateBotParam implements ITeamUpdateBotParam {
    name?: PatchOfString | null;

    constructor(data?: ITeamUpdateBotParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] ? PatchOfString.fromJS(_data["name"]) : <any>null;
        }
    }

    static fromJS(data: any): TeamUpdateBotParam {
        data = typeof data === 'object' ? data : {};
        let result = new TeamUpdateBotParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name ? this.name.toJSON() : <any>null;
        return data;
    }
}

export interface ITeamUpdateBotParam {
    name?: PatchOfString | null;
}

export class Role implements IRole {
    roleId!: string;
    roleName!: string;
    description?: string | null;

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"] !== undefined ? _data["roleId"] : <any>null;
            this.roleName = _data["roleName"] !== undefined ? _data["roleName"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
        }
    }

    static fromJS(data: any): Role {
        data = typeof data === 'object' ? data : {};
        let result = new Role();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId !== undefined ? this.roleId : <any>null;
        data["roleName"] = this.roleName !== undefined ? this.roleName : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data;
    }
}

export interface IRole {
    roleId: string;
    roleName: string;
    description?: string | null;
}

export class ListResultOfUserRole implements IListResultOfUserRole {
    totalCount?: number | null;
    items!: UserRole[];

    constructor(data?: IListResultOfUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"] !== undefined ? _data["totalCount"] : <any>null;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserRole.fromJS(item));
            }
            else {
                this.items = <any>null;
            }
        }
    }

    static fromJS(data: any): ListResultOfUserRole {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultOfUserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount !== undefined ? this.totalCount : <any>null;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultOfUserRole {
    totalCount?: number | null;
    items: UserRole[];
}

export class UserRole2 implements IUserRole2 {
    resourceId!: string;
    userId!: string;
    role!: Role;

    constructor(data?: IUserRole2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.role = new Role();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.resourceId = _data["resourceId"] !== undefined ? _data["resourceId"] : <any>null;
            this.userId = _data["userId"] !== undefined ? _data["userId"] : <any>null;
            this.role = _data["role"] ? Role.fromJS(_data["role"]) : new Role();
        }
    }

    static fromJS(data: any): UserRole2 {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resourceId"] = this.resourceId !== undefined ? this.resourceId : <any>null;
        data["userId"] = this.userId !== undefined ? this.userId : <any>null;
        data["role"] = this.role ? this.role.toJSON() : <any>null;
        return data;
    }
}

export interface IUserRole2 {
    resourceId: string;
    userId: string;
    role: Role;
}

export class UserRole extends UserRole2 implements IUserRole {
    user?: User | null;

    constructor(data?: IUserRole) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>null;
        }
    }

    static override fromJS(data: any): UserRole {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>null;
        super.toJSON(data);
        return data;
    }
}

export interface IUserRole extends IUserRole2 {
    user?: User | null;
}

export class TeamUserOfUserAndUserRoleAndRole implements ITeamUserOfUserAndUserRoleAndRole {
    user!: User;
    roles!: Role[];

    constructor(data?: ITeamUserOfUserAndUserRoleAndRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.roles = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(Role.fromJS(item));
            }
            else {
                this.roles = <any>null;
            }
        }
    }

    static fromJS(data: any): TeamUserOfUserAndUserRoleAndRole {
        data = typeof data === 'object' ? data : {};
        let result = new TeamUserOfUserAndUserRoleAndRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>null;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITeamUserOfUserAndUserRoleAndRole {
    user: User;
    roles: Role[];
}

export class TeamAddBotParam implements ITeamAddBotParam {
    name!: string;

    constructor(data?: ITeamAddBotParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): TeamAddBotParam {
        data = typeof data === 'object' ? data : {};
        let result = new TeamAddBotParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data;
    }
}

export interface ITeamAddBotParam {
    name: string;
}

export class TeamAddEmailParam implements ITeamAddEmailParam {

    constructor(data?: ITeamAddEmailParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): TeamAddEmailParam {
        data = typeof data === 'object' ? data : {};
        let result = new TeamAddEmailParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface ITeamAddEmailParam {
}

export class SignInRequest implements ISignInRequest {
    idToken!: string;
    refreshTokenType!: RefreshTokenType;

    constructor(data?: ISignInRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idToken = _data["idToken"] !== undefined ? _data["idToken"] : <any>null;
            this.refreshTokenType = _data["refreshTokenType"] !== undefined ? _data["refreshTokenType"] : <any>null;
        }
    }

    static fromJS(data: any): SignInRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SignInRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idToken"] = this.idToken !== undefined ? this.idToken : <any>null;
        data["refreshTokenType"] = this.refreshTokenType !== undefined ? this.refreshTokenType : <any>null;
        return data;
    }
}

export interface ISignInRequest {
    idToken: string;
    refreshTokenType: RefreshTokenType;
}

export enum RefreshTokenType {
    None = "None",
    Web = "Web",
    App = "App",
}

export class SignUpRequest implements ISignUpRequest {
    idToken!: string;
    refreshTokenType!: RefreshTokenType;

    constructor(data?: ISignUpRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idToken = _data["idToken"] !== undefined ? _data["idToken"] : <any>null;
            this.refreshTokenType = _data["refreshTokenType"] !== undefined ? _data["refreshTokenType"] : <any>null;
        }
    }

    static fromJS(data: any): SignUpRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SignUpRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idToken"] = this.idToken !== undefined ? this.idToken : <any>null;
        data["refreshTokenType"] = this.refreshTokenType !== undefined ? this.refreshTokenType : <any>null;
        return data;
    }
}

export interface ISignUpRequest {
    idToken: string;
    refreshTokenType: RefreshTokenType;
}

export class RefreshTokenRequest implements IRefreshTokenRequest {
    refreshToken!: string;

    constructor(data?: IRefreshTokenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refreshToken = _data["refreshToken"] !== undefined ? _data["refreshToken"] : <any>null;
        }
    }

    static fromJS(data: any): RefreshTokenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refreshToken"] = this.refreshToken !== undefined ? this.refreshToken : <any>null;
        return data;
    }
}

export interface IRefreshTokenRequest {
    refreshToken: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}

export class ApiException extends Error {
    statusCode: number;
    response?: string;
    exceptionTypeName?: string;
    exceptionTypeFullName?: string;
    headers: any;
    data: any = {};

    constructor(
        message: string,
        statusCode: number,
        response?: any,
        headers?: any,
        innerException?: Error | null
    ) {
        if (!(response instanceof String)) response = JSON.stringify(response);
        super(ApiException.buildMessage(message, statusCode, response));
        Object.setPrototypeOf(this, ApiException.prototype);

        this.statusCode = statusCode;
        this.response = response;
        this.headers = headers;

        let serverException: ServerException | null = ServerException.tryParse(response);
        if (serverException) {
            Object.keys(serverException.Data).forEach((key) => {
                if (serverException)
                    this.data[key] = serverException.Data[key];
            });
            this.exceptionTypeName = serverException.TypeName;
            this.exceptionTypeFullName = serverException.TypeFullName;
        }

        if (innerException) {
            this.stack = innerException.stack;
        }
    }

    private static buildMessage(
        message: string,
        statusCode: number,
        response?: string
    ): string {
        let serverException = ServerException.tryParse(response);
        if (serverException)
            return serverException.Message || '';

        return `${message}\n\nStatus: ${statusCode}\nResponse:\n${response?.substring(0, Math.min(512, response.length))}`;
    }

    override toString(): string {
        return `HTTP Response:\n\n${this.response}\n\n${super.toString()}`;
    }
}

class ServerException {
    Data!: { [key: string]: string | null };
    TypeName?: string;
    TypeFullName?: string;
    Message?: string;

    public static tryParse(value: string | undefined): ServerException | null {
        if (!value)
            return null;

        try {
            let serverException: ServerException = JSON.parse(value);
            return serverException.TypeName ? serverException : null;
        } catch {
            return null;
        }
    }
}